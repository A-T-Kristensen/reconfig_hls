#-----------------------------------------------------------
# Vivado v2016.4 (64-bit)
# SW Build 1733598 on Wed Dec 14 22:35:42 MST 2016
# IP Build 1731160 on Wed Dec 14 23:47:21 MST 2016
# Start of session at: Fri Feb 24 16:25:47 2017
# Process ID: 10847
# Current directory: /home/lpez/t-crest/reconfig/build/nexys4ddr-recon
# Command line: vivado -mode tcl
# Log file: /home/lpez/t-crest/reconfig/build/nexys4ddr-recon/vivado.log
# Journal file: /home/lpez/t-crest/reconfig/build/nexys4ddr-recon/vivado.jou
#-----------------------------------------------------------
source design_complete.tcl
# set tclParams [list hd.visual 0] 
# set tclHome "./tcl"
# if {[file exists $tclHome]} {
#    set tclDir $tclHome
# } elseif {[file exists "./tcl"]} {
#    set tclDir  "./tcl"
# } else {
#    error "ERROR: No valid location found for required Tcl scripts. Set \$tclDir in design.tcl to a valid location."
# }
# source $tclDir/design_utils.tcl
## set modules             [list ]
## set implementations     [list ]
## set opt_directives   [list Explore                \
##                            ExploreArea            \
##                            AddRemap               \
##                            ExploreSequentialArea  \
##                            RuntimeOptimized       \
##                            NoBramPowerOpt         \
##                            Default                \
##                      ]
## set place_directives [list Explore                \
##                            WLDrivenBlockPlacement \
##                            AltWLDrivenPlacement   \
##                            LateBlockPlacement     \
##                            ExtraNetDelay_high     \
##                            ExtraNetDelay_medium   \
##                            ExtraNetDelay_low      \
##                            SpreadLogic_high       \
##                            SpreadLogic_medium     \
##                            SpreadLogic_low        \
##                            ExtraPostPlacementOpt  \
##                            SSI_ExtraTimingOpt     \
##                            SSI_SpreadSLLs         \
##                            SSI_BalanceSLLs        \
##                            SSI_BalanceSLRs        \
##                            SSI_HighUtilSLRs       \
##                            RuntimeOptimized       \
##                            Quick                  \
##                            Default                \
##                      ]
## set phys_directives  [list Explore                \
##                            ExploreWithHoldFix     \
##                            AggressiveExplore      \
##                            AlternateReplication   \
##                            AggressiveFanoutOpt    \
##                            AlternateDelayModeling \
##                            AddRetime              \
##                            AlternateFlowWithRetiming \
##                            Default                \
##                      ]
## set route_directives [list Explore                \
##                            NoTimingRelaxation     \
##                            MoreGlobalIterations   \
##                            HigherDelayCost        \
##                            AdvancedSkewModeling   \
##                            RuntimeOptimized       \
##                            Quick                  \
##                            Default                \
##                       ]
## array set module_attributes [list "moduleName"           [list string   null]  \
##                                   "top_level"            [list boolean {0 1}]  \
##                                   "prj"                  [list string   null]  \
##                                   "includes"             [list string   null]  \
##                                   "generics"             [list string   null]  \
##                                   "vlog_headers"         [list string   null]  \
##                                   "vlog_defines"         [list string   null]  \
##                                   "sysvlog"              [list string   null]  \
##                                   "vlog"                 [list string   null]  \
##                                   "vhdl"                 [list string   null]  \
##                                   "ip"                   [list string   null]  \
##                                   "ipRepo"               [list string   null]  \
##                                   "bd"                   [list string   null]  \
##                                   "cores"                [list string   null]  \
##                                   "xdc"                  [list string   null]  \
##                                   "synthXDC"             [list string   null]  \
##                                   "implXDC"              [list string   null]  \
##                                   "synth"                [list boolean {0 1}]  \
##                                   "synth_options"        [list string   null]  \
##                                   "synthCheckpoint"      [list string   null]  \
##                             ]
## array set impl_attributes   [list "top"                  [list string   null]  \
##                                   "name"                 [list string   null]  \
##                                   "implXDC"              [list string   null]  \
##                                   "linkXDC"              [list string   null]  \
##                                   "cores"                [list string   null]  \
##                                   "ip"                   [list string   null]  \
##                                   "ipRepo"               [list string   null]  \
##                                   "impl"                 [list boolean {0 1}]  \
##                                   "hd.impl"              [list boolean {0 1}]  \
##                                   "td.impl"              [list boolean {0 1}]  \
##                                   "pr.impl"              [list boolean {0 1}]  \
##                                   "ic.impl"              [list boolean {0 1}]  \
##                                   "incr.impl"            [list boolean {0 1}]  \
##                                   "ooc.impl"             [list boolean {0 1}]  \
##                                   "iso.impl"             [list boolean {0 1}]  \
##                                   "pr.budget"            [list boolean {0 1}]  \
##                                   "pr.budget_exclude"    [list string   null]  \
##                                   "partitions"           [list string   null   \
##                                                                string   null   \
##                                                                enum    {implement import greybox}  \
##                                                                string   null   \
##                                                                enum    {default ooc iso}           \
##                                                                enum    {logical placement routing} \
##                                                                string   null   \
##                                                          ] \
##                                   "link"                 [list boolean {0 1}]  \
##                                   "opt"                  [list boolean {0 1}]  \
##                                   "opt.pre"              [list string   null]  \
##                                   "opt_options"          [list string   null]  \
##                                   "opt_directive"        [list enum     $opt_directives]   \
##                                   "place"                [list boolean {0 1}]  \
##                                   "place.pre"            [list string   null]  \
##                                   "place_options"        [list string   null]  \
##                                   "place_directive"      [list enum     $place_directives] \
##                                   "phys"                 [list boolean {0 1}]  \
##                                   "phys.pre"             [list string   null]  \
##                                   "phys_options"         [list string   null]  \
##                                   "phys_directive"       [list enum     $phys_directives]  \
##                                   "route"                [list boolean {0 1}]  \
##                                   "route.pre"            [list string   null]  \
##                                   "route_options"        [list string   null]  \
##                                   "route_directive"      [list enum     $route_directives] \
##                                   "verify"               [list boolean {0 1}]  \
##                                   "bitstream"            [list boolean {0 1}]  \
##                                   "bitstream.pre"        [list string   null]  \
##                                   "bitstream_options"    [list string   null]  \
##                                   "bitstream_settings"   [list string   null]  \
##                                   "cfgmem.icap"          [list boolean {0 1}]  \
##                                   "cfgmem.pcap"          [list boolean {0 1}]  \
##                                   "cfgmem.offset"        [list string   null]  \
##                                   "cfgmem.size"          [list enum    {1 2 4 8 16 32 64 128 256 512}] \
##                                   "cfgmem.interface"     [list enum    {SMAPx8 SMAPx16 SMAPx32}] \
##                                   "drc.quiet"            [list boolean {0 1}]  \
##                             ]
## proc add_implementation { name } {
##    global implementations
##    set procname [lindex [info level 0] 0]
##    
##    if {[lsearch -exact $implementations $name] >= 0} {
##       set errMsg "\nERROR: Implementation $name is already defined"
##       error $errMsg
##    }
## 
##    lappend implementations $name
##    set_attribute impl $name "top"                 ""
##    set_attribute impl $name "name"                $name
##    set_attribute impl $name "implXDC"             "" 
##    set_attribute impl $name "linkXDC"             "" 
##    set_attribute impl $name "cores"               ""
##    set_attribute impl $name "ip"                  ""
##    set_attribute impl $name "ipRepo"              ""
##    set_attribute impl $name "impl"                0
##    set_attribute impl $name "hd.impl"             0
##    set_attribute impl $name "td.impl"             0
##    set_attribute impl $name "pr.impl"             0
##    set_attribute impl $name "ic.impl"             0
##    set_attribute impl $name "incr.impl"           0
##    set_attribute impl $name "ooc.impl"            0
##    set_attribute impl $name "iso.impl"            0
##    set_attribute impl $name "pr.budget"           0
##    set_attribute impl $name "pr.budget_exclude"   ""
##    set_attribute impl $name "link"                1
##    set_attribute impl $name "partitions"          ""
##    set_attribute impl $name "opt"                 1
##    set_attribute impl $name "opt.pre"             ""
##    set_attribute impl $name "opt_options"         ""
##    set_attribute impl $name "opt_directive"       ""
##    set_attribute impl $name "place"               1
##    set_attribute impl $name "place.pre"           ""
##    set_attribute impl $name "place_options"       ""
##    set_attribute impl $name "place_directive"     ""
##    set_attribute impl $name "phys"                1
##    set_attribute impl $name "phys.pre"            ""
##    set_attribute impl $name "phys_options"        ""
##    set_attribute impl $name "phys_directive"      ""
##    set_attribute impl $name "route"               1
##    set_attribute impl $name "route.pre"           ""
##    set_attribute impl $name "route_options"       ""
##    set_attribute impl $name "route_directive"     ""
##    set_attribute impl $name "verify"              0
##    set_attribute impl $name "bitstream"           0
##    set_attribute impl $name "bitstream.pre"       ""
##    set_attribute impl $name "bitstream_options"   ""
##    set_attribute impl $name "bitstream_settings"  ""
##    set_attribute impl $name "cfgmem.icap"         0
##    set_attribute impl $name "cfgmem.pcap"         0
##    set_attribute impl $name "cfgmem.offset"       "up 0x0"
##    set_attribute impl $name "cfgmem.size"         "1"
##    set_attribute impl $name "cfgmem.interface"    "SMAPx32"
##    set_attribute impl $name "drc.quiet"           0
## }
## proc add_module { name } {
##    global modules synthDir
## 
##    if {[lsearch -exact $modules $name] >= 0} {
##       set errMsg "\nERROR: Module $name is already defined"
##       error $errMsg
##    }
## 
##    lappend modules $name
##    set_attribute module $name "moduleName"       $name
##    set_attribute module $name "top_level"        0
##    set_attribute module $name "prj"              ""
##    set_attribute module $name "includes"         ""
##    set_attribute module $name "generics"         ""
##    set_attribute module $name "vlog_headers"     [list ]
##    set_attribute module $name "vlog_defines"     ""
##    set_attribute module $name "sysvlog"          [list ]
##    set_attribute module $name "vlog"             [list ]
##    set_attribute module $name "vhdl"             [list ]
##    set_attribute module $name "ip"               [list ]
##    set_attribute module $name "ipRepo"           [list ]
##    set_attribute module $name "bd"               [list ]
##    set_attribute module $name "cores"            [list ]
##    set_attribute module $name "xdc"              [list ]
##    set_attribute module $name "synthXDC"         [list ]
##    set_attribute module $name "implXDC"          [list ]
##    set_attribute module $name "synth"            0 
##    set_attribute module $name "synth_options"    "-flatten_hierarchy rebuilt" 
##    set_attribute module $name "synthCheckpoint"  ""
## }
## proc set_attribute { type name attribute {values null} } {
##    global ${type}Attribute
##    set procname [lindex [info level 0] 0]
## 
##    switch -exact -- $type {
##       module  {set list_type "modules"}
##       impl    {set list_type "implementations"}
##       default {error "\nERROR: Invalid type \'$type\' specified"}
##    }
## 
##    check_list $list_type $name $procname
##    check_attribute $type $attribute $procname
##    if {![string match $values "null"]} {
##       foreach value $values {
##          check_attribute_value $type $attribute $value
##       }
##       set ${type}Attribute(${name}.$attribute) $values
##    } else {
##       puts "Critical Warning: Attribute $attribute for $type $name is set to $values. The value will not be modified."
##    }
##    return $values
## }
## proc get_attribute { type name attribute } {
##    global ${type}Attribute
##    set procname [lindex [info level 0] 0]
## 
##    switch -exact -- $type {
##       module  {set list_type "modules"}
##       impl    {set list_type "implementations"}
##       default {error "\nERROR: Invalid type \'$type\' specified"}
##    }
## 
##    check_list $list_type $name $procname
##    check_attribute $type $attribute $procname
##    return [subst -nobackslash \$${type}Attribute(${name}.$attribute)]
## }
## proc check_attribute { type attribute procname } {
##    global ${type}_attributes
##    set attributes [array names ${type}_attributes]
##    if {[lsearch -exact $attributes $attribute] < 0} {
##       set errMsg "\nERROR: Invalid $type attribute \'$attribute\' specified in $procname"
##       error $errMsg
##    }
## }
## proc check_attribute_value { type attribute values } {
##    global ${type}_attributes 
##    if {[info exists ${type}_attributes($attribute)]} {
##       set attribute_checks [subst -nobackslashes \$${type}_attributes($attribute)]
##       set index 0
##       foreach {attr_type attr_values} $attribute_checks {
##          set value [lindex $values $index]
##          if {![string match $attr_values "null"] && [llength $value]} {
##             set pass 0
##             foreach attr_value $attr_values {
##                if {$attr_value==$value} {
##                   set pass 1
##                }
##             }
##             if {$pass==0} {
##                set errMsg "\nERROR: Value \'$value\' of $type attribute $attribute of type $attr_type is not valid.\n"
##                append errMsg "Supported values are: $attr_values"
##                error $errMsg
##             }
##          }
##          incr index
##       }
##    } else {
##       set errMsg "\nERROR: Could not find attribute $attribute in array ${type}_attributes."
##       error $errMsg
##    }
## }
## proc check_list { list_type name procname } {
##    global [subst $list_type]
##    if {[lsearch -exact [subst -nobackslash \$$list_type] $name] < 0} {
##       set errMsg "\nERROR: Invalid $list_type \'$name\' specified in $procname"
##       error $errMsg 
##    }
## }
## proc set_directives {$type $name} {
##    global Directives
##      
##    set_attribute $type $name opt_directive   $Directives(opt)
##    set_attribute $type $name place_directive $Directives(place)
##    set_attribute $type $name phys_directive  $Directives(phys)
##    set_attribute $type $name route_directive $Directives(route)
## }
## proc list_runs { } {
##    #### Print list of Modules
##    if {[llength [get_modules synth]]} {
##       set table "-title {#HD: List of modules to be synthesized}"
##       append table " -row {Module \"Module Name\" \"Top Level\" Options}"
##       foreach module [get_modules synth] {
##          set moduleName [get_attribute module $module moduleName] 
##          set top [get_attribute module $module top_level]
##          set synth_options [get_attribute module $module synth_options]
##          append table " -row {$module $moduleName $top \"$synth_options\"}"
##       }
##       print_table $table 
##    } else {
##       puts "#HD: No modules set to be synthesized"
##    }
##    if {[llength [get_modules !synth]]} {
##       puts "#HD: Defined modules not being synthesized:"
##       set count 1
##       foreach module [get_modules !synth] {
##          puts "\t$count. $module ([get_attribute module $module moduleName])"
##          incr count
##       }
##    }
## 
##    #### Print list of Configurations
##    if {[llength [get_implementations "pr.impl impl" &&]]} {
##       set configs [sort_configurations [get_implementations "pr.impl impl" &&]]
##       set table "-title {#HD: List of Configurations to be implemented}"
##       append table " -row {Configuration \"Reconfig Modules\" \"Static State\" pr_verify write_bistream}"
##       #Sort list of configurations. Insert "initial" config at beginning of list.
##       foreach configuration $configs { 
##          set partitions [get_attribute impl $configuration partitions]
##          set top        [get_attribute impl $configuration top]
##          set verify     [get_attribute impl $configuration verify]
##          set bitstream  [get_attribute impl $configuration bitstream]
##          set RMs ""
##          set staticState ""
##          foreach partition $partitions {
##             lassign $partition module cell state name type level dcp
##             if {![string match $cell $top]} {
##                if {[string match $state "greybox"]} {
##                   lappend RMs "$state"
##                } else {
##                   lappend RMs "$module\($state\)"
##                }
##             } else {
##                set staticState $state
##             }
##          }
##          set rmCount [llength $RMs]
##          for {set i 0} {$i < $rmCount} {incr i} {
##             if {$i==0} {
##                append table " -row {$configuration [lindex $RMs $i] $staticState $verify $bitstream}"
##             } else {
##                append table " -row {\"\" [lindex $RMs $i] \"\" \"\" \"\"}"
##             } 
##          }
##       }
##       print_table $table 
##    } else {
##       puts "#HD: No Configurations set to be implemented"
##    }
##    if {[llength [get_implementations "pr.impl !impl" &&]]} {
##       puts "#HD: Defined Configurations not being implemented:"
##       set count 1
##       foreach config [get_implementations "pr.impl !impl" &&] {
##          puts "\t$count. $config"
##          incr count
##       }
##    }
## 
##    #### Print list of Implementations
##    if {[llength [get_implementations "!pr.impl impl" &&]]} {
##       set table "-title {#HD: List of Implementations to be implemented}"
##       append table " -row {Implementation Top Partitions \"Flow Type\" write_bistream}"
##       foreach impl [get_implementations "!pr.impl impl" &&] {
##          set partitions [get_attribute impl $impl partitions]
##          set top        [get_attribute impl $impl top]
##          set hd         [get_attribute impl $impl hd.impl]
##          set td         [get_attribute impl $impl td.impl]
##          set ic         [get_attribute impl $impl ic.impl]
##          set incr       [get_attribute impl $impl incr.impl]
##          set ooc        [get_attribute impl $impl ooc.impl]
##          set iso        [get_attribute impl $impl iso.impl]
##          set bitstream  [get_attribute impl $impl bitstream]
## 
##          if {$hd} {
##             set runType "Assembly"
##          } elseif {$td} {
##             set runType "Top-Down"
##          } elseif {$ic} {
##             set runType "In-Context"
##          } elseif {$incr} {
##             set runType "Incremental"
##          } elseif {$ooc} {
##             set runType "Out-of-Context"
##          } elseif {$iso} {
##             set runType "Isolation"
##          } else {
##             set runType "Flat"
##          }
## 
##          set hdCells "" 
##          set state ""
##          set topState "implement"
##          foreach partition $partitions {
##             lassign $partition module cell state name type level dcp
##             if {![string match $cell $top]} {
##                if {![llength $name]} {
##                   set name [lindex [split $cell "/"] end]
##                }
##                lappend hdCells "$name\($state\)"
##             } else {
##                set topState $state
##             }
##          }
## 
##          if {[llength $hdCells]} {
##             for {set i 0} {$i < [llength $hdCells]} {incr i} {
##                if {$i==0} {
##                   append table " -row {$impl $top\($topState\) [lindex $hdCells $i] $runType $bitstream}"
##                } else {
##                   append table " -row {\"\" \"\"  [lindex $hdCells $i] \"\" \"\"}"
##                } 
##             }
##          } else {
##             append table " -row {$impl $top\($topState\) \"\" $runType $bitstream}"
##          }
##       }
##       print_table $table 
##    }
##    if {[llength [get_implementations "!pr.impl !impl" &&]]} {
##       puts "#HD: Defined Implementations not being implemented:"
##       set count 1
##       foreach impl [get_implementations "!pr.impl !impl" &&] {
##          puts "\t$count. $impl"
##          incr count
##       }
##    }
##    puts "\n"
## }
## proc sort_configurations { configurations } {
##    set configs "" 
##    #Sort list of configurations. Insert "initial" config at beginning of list.
##    foreach configuration $configurations {
##       set partitions [get_attribute impl $configuration partitions]
##       set top        [get_attribute impl $configuration top]
##       foreach partition $partitions {
##          lassign $partition module cell state name type level dcp
##          if {[string match $cell $top]} {
##             if {[string match -nocase $state "implement"]} {
##                set configs [linsert $configs 0 $configuration]
##             } else {
##                lappend configs $configuration
##             }
##          }
##       }
##    }
## 
##    #Make sure no configurations get lost in the sort
##    if {[llength $configs] == [llength $configurations]} {
##       return $configs
##    } else {
##       set errMsg "\nERROR: Number of configurations changed during sorting process." 
##       error $errMsg
##    }
## }
## proc set_parameters {params} {
##    command "puts \"\t#HD: Setting Tcl Params:\""
##    foreach {name value} $params   {
##       puts "\t$name == $value"
##       command "set_param $name $value"
##    }
##    puts "\n"
## }
## proc report_attributes { type name } {
##    global ${type}Attribute
##    global ${type}_attributes
##    set procname [lindex [info level 0] 0]
##    set widthCol1 18
##    set widthCol2 90
## 
##    switch -exact -- $type {
##       module  {set list_type "modules"}
##       impl    {set list_type "implementations"}
##       default {error "\nERROR: Invalid type \'$type\' specified"}
##    }
## 
##    check_list $list_type $name $procname
##    puts "Report $type properties for $name:"
##    puts "| [string repeat - $widthCol1] | [string repeat - $widthCol2] |"
##    puts [format "| %-*s | %-*s |" $widthCol1 "Attribute" $widthCol2 "Value"]
##    puts "| [string repeat - $widthCol1] | [string repeat - $widthCol2] |"
##    foreach {attribute } [lsort [array names ${type}_attributes]] {
##       set value [subst -nobackslash \$${type}Attribute(${name}.$attribute)]
##       puts [format "| %-*s | %-*s |" $widthCol1 $attribute $widthCol2 $value]
##    }
##    puts "| [string repeat - $widthCol1] | [string repeat - $widthCol2] |"
## }
## proc get_configurations { } {
##    set configurations [get_implementations pr.impl]
##    return $configurations
## }
## proc get_ooc_implementations { } {
##    set implementations [get_implementations "ooc.impl iso.impl" ||]
##    return $implementations
## }
## proc get_modules { {filters ""} {function &&} } {
##    upvar #0 modules modules
## 
##    if {[llength $filters]} {
##       set filtered_modules ""
##       foreach module $modules {
##          foreach filter $filters {
##             #Check if value is "not", and remove ! from name
##             if {[regexp {!(.*)} $filter old filter]} {
##                set value 0
##             } else {
##                set value 1
##             }
##             if {[get_attribute module $module $filter] == $value} {
##                set match 1
##                if {[string match $function "||"]} {
##                   #Add matching filter results if not already added
##                   if {[lsearch -exact $filtered_modules $module] < 0} {
##                      lappend filtered_modules $module
##                      break
##                   }
##                }
##             } else {
##                set match 0
##                if {[string match $function "&&"]} {
##                   break
##                }
##             }
##          }
##          if {$match && [string match $function "&&"]} {
##             #Add matching filter results if not already added
##             if {[lsearch -exact $filtered_modules $module] < 0} {
##                lappend filtered_modules $module
##             }
##          }
##       }
##       return $filtered_modules
##    } else {
##       return $modules
##    }
## }
## proc get_implementations { {filters ""} {function &&} } {
##    upvar #0 implementations implementations
## 
##    if {[llength $filters]} {
##       set filtered_implementations ""
##       foreach implementation $implementations {
##          foreach filter $filters {
##             #Check if value is "not", and remove ! from name
##             if {[regexp {!(.*)} $filter old filter]} {
##                set value 0
##             } else {
##                set value 1
##             }
##             if {[get_attribute impl $implementation $filter] == $value} {
##                set match 1
##                if {[string match $function "||"]} {
##                   #Add matching filter results if not already added
##                   if {[lsearch -exact $filtered_implementations $implementation] < 0} {
##                      lappend filtered_implementations $implementation
##                      break
##                   }
##                }
##             } else {
##                set match 0
##                if {[string match $function "&&"]} {
##                   break
##                }
##             }
##          }
##          if {$match && [string match $function "&&"]} {
##             #Add matching filter results if not already added
##             if {[lsearch -exact $filtered_implementations $implementation] < 0} {
##                lappend filtered_implementations $implementation
##             }
##          }
##       }
##       return $filtered_implementations
##    } else {
##       return $implementations
##    }
## }
## proc check_part {part} {
##    set device [lindex [split $part -] 0]
##    if {![llength [get_parts $part]]} {
##       puts "ERROR: No valid part found matching specifiec part:\n\t$part"
##       if {[llength [get_parts ${device}*]]} {
##          puts "Valid part combinations for $device:"
##          puts "\t[join [get_parts ${device}*] \n\t]"
##       }
##       error "ERROR: Check value of specified part."
##    } else {
##       puts "INFO: Found part matching $part"
##    }
## }
# source $tclDir/log_utils.tcl
## if {[info exists tclDir]} {
##    set runLog "run"
##    set commandLog "command"
##    set criticalLog "critical"
## 
##    set logs [list $runLog $commandLog $criticalLog]
##    foreach log $logs {
##       if {[file exists ${log}.log]} {
##          file copy -force $log.log ${log}_prev.log
##       }
##    }
## 
##    set RFH [open "$runLog.log" w]
##    set CFH [open "$commandLog.log" w]
##    set WFH [open "$criticalLog.log" w]
## }
## proc log_time {phase start_time end_time {header 0} {notes ""} } {
##    global RFH
##    upvar #1 rfh rfh
## 
##    if {![info exists rfh]} {
##       set rfh "stdout"
##    }
##    #Define widths of each column
##    set widthCol1 19
##    set widthCol2 13
##    set widthCol3 25
##    set widthCol4 65
## 
##    #Calculate times based of passed in times
##    set total_seconds [expr $end_time - $start_time]
##    set total_minutes [expr $total_seconds / 60]
##    set total_hours [expr $total_minutes / 60]
## 
##    if {$header} {
##       puts $rfh "\n| [string repeat - $widthCol1] | [string repeat - $widthCol2] | [string repeat - $widthCol3] | [string repeat - $widthCol4] |"
##       puts $rfh [format "| %-*s | %-*s | %-*s | %-*s |" $widthCol1 "Phase" $widthCol2 "Time in Phase" $widthCol3 "Time\/Date" $widthCol4 "Description"]
##       puts $rfh "| [string repeat - $widthCol1] | [string repeat - $widthCol2] | [string repeat - $widthCol3] | [string repeat - $widthCol4] |"
##       puts $RFH "\n| [string repeat - $widthCol1] | [string repeat - $widthCol2] | [string repeat - $widthCol3] | [string repeat - $widthCol4] |"
##       puts $RFH [format "| %-*s | %-*s | %-*s | %-*s |" $widthCol1 "Phase" $widthCol2 "Time in Phase" $widthCol3 "Time\/Date" $widthCol4 "Description"]
##       puts $RFH "| [string repeat - $widthCol1] | [string repeat - $widthCol2] | [string repeat - $widthCol3] | [string repeat - $widthCol4] |"
##    }
## 
##    if {[string match $phase final]} {
##       set time "[format %02d [expr $total_hours]]h:[format %02d [expr $total_minutes-($total_hours*60)]]m:[format %02d [expr $total_seconds-($total_minutes*60)]]s"
##       puts $rfh "Total time:\t\t$time"
##       puts $RFH "Total time:\t\t$time"
##    } else {
##       set time "[format %02d [expr $total_hours]]h:[format %02d [expr $total_minutes-($total_hours*60)]]m:[format %02d [expr $total_seconds-($total_minutes*60)]]s"
##       set date "[clock format $start_time -format {%H:%M:%S %a %b %d %Y}]"
##       puts $rfh [format "| %-*s | %-*s | %-*s | %-*s |" $widthCol1 "$phase" $widthCol2 "$time" $widthCol3 "$date" $widthCol4 "$notes"]
##       puts $rfh "| [string repeat - $widthCol1] | [string repeat - $widthCol2] | [string repeat - $widthCol3] | [string repeat - $widthCol4] |"
##       puts $RFH [format "| %-*s | %-*s | %-*s | %-*s |" $widthCol1 "$phase" $widthCol2 "$time" $widthCol3 "$date" $widthCol4 "$notes"]
##       puts $RFH "| [string repeat - $widthCol1] | [string repeat - $widthCol2] | [string repeat - $widthCol3] | [string repeat - $widthCol4] |"
##    } 
##    flush $rfh
##    flush $RFH
## }
## proc log_data {impl instance} {
##    global implDir RFH
##    upvar #1 rfh rfh
##    
##    set resultDir $implDir/$impl
##       
##    set route_log $resultDir/${instance}_route_design.log
##    if {[file exists $route_log]} {
##       set log_fh [open $route_log r]
##       set log_data [read $log_fh]
##       close $log_fh
##       set log_lines [split $log_data "\n" ]
##       set timing ""
##       foreach line $log_lines {
##          if {[string match "*Route 35-57*" $line]} {
##             set timing $line
##          }
##       }
##       if {[llength $timing]} {
##          puts $rfh "\t$timing"
##          puts $RFH "\t$timing"
##       }
##    } else {
##       puts $rfh "Could not find route_design log file \"$route_log\"."
##       puts $RFH "Could not find route_design log file \"$route_log\"."
##    }
##    puts $rfh "\n"
##    puts $RFH "\n"
##    flush $rfh
##    flush $RFH
## }
## proc command { command  {log ""} {quiet 0} } {
##    global verbose CFH
##    upvar #1 cfh cfh
##    
##    if {![info exists cfh]} {
##       set cfh "stdout"
##    }
## 
##    if {![info exists CFH]} {
##       set CFH "stdout"
##    }
## 
##    #Write all commands to command.log if file hanlde exists
##    if {![string match $cfh "stdout"]} {
##       puts $cfh $command
##       flush $cfh
##    }
##    if {![string match $CFH "stdout"]} {
##       puts $CFH $command
##       flush $CFH
##    }
## 
##    #ignore new-line, comments, or if verbose=0 (to generate scripts only)
##    if {[string match "\n" $command] || [string match "#*" $command] || !$verbose} {
##       return 0
##    }
## 
##    if {$verbose > 1} {
##       puts "\tCOMMAND: $command"
##    }
## 
##    set commandName [lindex [split $command] 0]
##    if {[llength $log] > 0} {
##       if { [catch "$command > $log" errMsg] && !$quiet } {
##          parse_log $log
##          regexp {(\.*.*)(\..*)} $log matched logName logType
##          #If design is open write out a debug DCP
##          if { ![catch {current_instance}] } {
##             puts "#HD: Writing checkpoint ${logName}_error.dcp for debug."
##             command "write_checkpoint -force ${logName}_error.dcp"
##          }
##          #upvar start_time start_time
##          upvar #1 start_time start_time
##          set end_time [clock seconds]
##          log_time $commandName $start_time $end_time 0 $errMsg
##          append errMsg "\nERROR: $commandName command \"$command\" failed.\nSee log file $log for more details."
##          error $errMsg
##       }
##       #Prevent messages from being dumped to terminal if quiet mode
##       if {!$quiet} {
##          parse_log $log
##       }
##    } else {
##       if { [catch $command errMsg] && !$quiet} {
##          append errMsg "\nERROR: $commandName command failed.\n\t$command\n"
##          error $errMsg
##       }
##    }
## }
## proc parse_log { log } {
##    global RFH WFH
##    upvar #1 wfh wfh
##    upvar #1 rfh rfh
## 
##    if {![info exists rfh]} {
##       set rfh "stdout"
##    }
##    if {![info exists wfh]} {
##       set wfh "stdout"
##    }
##    if {[file exists $log]} {
##       set lfh [open $log r]
##       set log_data [read $lfh]
##       close $lfh
##       set log_lines [split $log_data "\n" ]
##       puts $wfh "\t#HD: Parsing log file \"$log\":"
##       puts $WFH "\t#HD: Parsing log file \"$log\":"
##       foreach line $log_lines {
##          if {[string match "CRITICAL WARNING*" $line]} {
##             puts $wfh "\t$line"
##             puts $WFH "\t$line"
##          }
##          if {[string match "WARNING \[Route 35-328\]*" $line]} {
##             puts $rfh "\t$line"
##             puts $RFH "\t$line"
##          }
##          if {[string match "ERROR:*" $line]} {
##             puts $rfh $line
##             puts $RFH $line
##             puts $line
##          }
##       }
##    } else {
##       puts $wfh "ERROR: Could not find specified log file \"$log\"."
##       puts $WFH "ERROR: Could not find specified log file \"$log\"."
##    }
##    puts $wfh "\n"
##    puts $WFH "\n"
##    flush $wfh
##    flush $WFH
## }
## proc read_file_lines {file} {
##    if {![file exists $file]} {
##       puts "Error: Specified file $file does not exist. Please check path."
##       return
##    }
##    set fh [open $file r]
##    set fileData [read $fh]
##    close $fh
##    set fileLines [split $fileData "\n" ]
##    return $fileLines
## }
## proc print_table { args } {
##    set args [join $args]
##    set title "Table"
##    set FH "stdout"
## 
##    #Override defaults with command options
##    set argLength [llength $args]
##    set index 0
##    set rowCount 0
##    while {$index < $argLength} {
##       set arg [lindex $args $index]
##       set value [lindex $args [expr $index+1]]
##       switch -exact -- $arg {
##          {-title}    {set title $value}
##          {-row}      {dict set rows row${rowCount} $value
##                       incr rowCount
##                      }
##          {-file}     {set FH [open $value w]}
##          {-handle}   {upvar $value FH}
##          {-help}     {set     helpMsg "Description:"
##                       lappend helpMsg "Prints out a table in order the Rows are specified.\n"
##                       lappend helpMsg "Syntax:"
##                       lappend helpMsg "print_table\t\[-row <row1>] ... \[-row <rowN] \[-file <arg>]\n"
##                       lappend helpMsg "Usage:"
##                       lappend helpMsg "  Name                        Description"
##                       lappend helpMsg "  -------------------------------------------------------------------------------"
##                       lappend helpMsg "  \[-title]                    Optional. Defines the title of the table."
##                       lappend helpMsg "                              A default table name is used if no title is defined" 
##                       lappend helpMsg "  \[-row]                      Required. Defines a Row of the table to be printed."
##                       lappend helpMsg "                              The order the rows are defined is the print order." 
##                       lappend helpMsg "  \[-file]                     Optional. Specifies the output file name."
##                       lappend helpMsg "                              If not specified the output will be written to STDOUT"
##                       lappend helpMsg "  \[-help]                     Displays this message\n\n"
##                       foreach line $helpMsg {
##                          puts $FH $line
##                       }
##                       return
##                      }
##          default     {set errMsg "ERROR: Specified argument $arg is not supported.\n"
##                       append errMsg "Supported arguments are -help, -title, -row, and -file.\n"
##                       append errMsg "Use the -help option for more details"
##                       error $errMsg 
##                      }
##       }
##       set index [expr $index + 2]
##    }
## 
## 
##    #Create an array for column widths for each header entry
##    set headers [dict get $rows row0]
##    set colCount 0
##    set colTotal [llength $headers]
##    foreach header $headers {
##       set colWidth($colCount) [expr [string length $header] + 1]
##       incr colCount
##    }
## 
##    
##    #Get max length of entry, and update colWidth if necessary
##    dict for {row entries} $rows {
##       set colCount 0
##       set rowTotal [llength $entries]
##       if {$rowTotal != $colTotal} {
##          set errMsg "Error: The number of entries for $row does match the number of entries for row0.\n"
##          append errMsg "row0: [dict get $rows row0]\n"
##          append errMsg "$row: [dict get $rows $row]\n"
##          error $errMsg
##       }
##       foreach cell $entries {
##          set length [expr [string length $cell] + 1]
##          #puts "$colCount: $cell: $length"
##          if {$length > $colWidth($colCount) } {
##             set colWidth($colCount) $length
##          }
##          incr colCount
##       }
##    }
## 
##    #Create a string to seperate each row/column of data
##    set separator "|"
##    set colCount 0
##    foreach {key value} [array get colWidth] {
##       set width $colWidth($colCount)
##       append separator " [string repeat - $width] |"
##       incr colCount
##    }
## 
##    #Create the necessary string for each row to be used with "format" command
##    #[format "| %-*s | %-*s | %-*s | %-*s | %-*s | %-*s |" $width1 $value1 $width2 $value2 ... $widthN $valueN]
##    set rowCount 0
##    dict for {row entries} $rows {
##       dict set table row${rowCount} "\"|"
##       foreach cell $entries {
##          dict append table row${rowCount} " %-*s |"
##       }
##       dict append table row${rowCount} "\""
##       #puts "[dict get $table row${rowCount}]"
##       incr rowCount
##    }
## 
##    #Add additional information to each row to complete information needed for "format" command
##    #[format "| %-*s | %-*s | %-*s | %-*s | %-*s | %-*s |" $width1 $value1 $width2 $value2 ... $widthN $valueN]
##    set rowCount 0
##    dict for {row entries} $rows {
##       set col 0
##       foreach cell $entries {
##          dict append table row${rowCount} " $colWidth($col) \"$cell\""
##          incr col
##       }
##       #puts "[dict get $table row${rowCount}]"
##       incr rowCount
##    }
## 
##    #Print the Table
##    puts $FH "\n$title:"
##    dict for {row value} $table {
##       puts $FH $separator
##       puts $FH [eval format $value]
##    }
##    puts $FH "$separator\n"
## 
##    #Close the file handle if -file was specified
##    if {![string match $FH "stdout"]} {
##       close $FH
##    }
## }
# source $tclDir/synth_utils.tcl
## source $tclDir/synthesize.tcl
### proc synthesize { module } {
###    global tclParams 
###    global part 
###    global board 
###    global synthDir
###    global srcDir
###    global verbose
###    
###    set moduleName  [get_attribute module $module moduleName]
###    set topLevel    [get_attribute module $module top_level]
###    set prj         [get_attribute module $module prj]
###    set includes    [get_attribute module $module includes]
###    set generics    [get_attribute module $module generics]
###    set vlogHeaders [get_attribute module $module vlog_headers]
###    set vlogDefines [get_attribute module $module vlog_defines]
###    set sysvlog     [get_attribute module $module sysvlog]
###    set vlog        [get_attribute module $module vlog]
###    set vhdl        [get_attribute module $module vhdl]
###    set ip          [get_attribute module $module ip]
###    set ipRepo      [get_attribute module $module ipRepo]
###    set bd          [get_attribute module $module bd]
###    set cores       [get_attribute module $module cores]
###    set xdc         [get_attribute module $module xdc]
###    set synthXDC    [get_attribute module $module synthXDC]
###    set options     [get_attribute module $module synth_options]
### 
###    set resultDir "$synthDir/$module"
### 
###    # Make the synthesis directory if needed
###    if {![file exists $synthDir]} {
###       file mkdir $synthDir
###    }
###    # Clean-out and re-make the synthesis directory for this module
###    file delete -force $resultDir
###    file mkdir $resultDir
###    
###    #Open local log files
###    set rfh [open "$resultDir/run.log" w]
###    set cfh [open "$resultDir/command.log" w]
###    set wfh [open "$resultDir/critical.log" w]
###    
###    command "puts \"#HD: Running synthesis for block $module\""
###    puts "\tWriting results to: $resultDir"
###    set synth_start [clock seconds]
### 
###    #### Set Tcl Params
###    if {[info exists tclParams] && [llength $tclParams] > 0} {
###       set_parameters $tclParams
###    }
### 
###    #Create in-memory project
###    command "create_project -in_memory -part $part" "$resultDir/create_project.log"
### 
###    if {[info exists board] && [llength $board]} {
###       command "set_property board_part $board \[current_project\]"
###    }
### 
###    #### Setup any IP Repositories 
###    if {$ipRepo != ""} {
###       puts "\tLoading IP Repositories:\n\t+ [join $ipRepo "\n\t+ "]"
###       command "set_property IP_REPO_PATHS \{$ipRepo\} \[current_fileset\]" "$resultDir/temp.log"
###       command "update_ip_catalog" "$resultDir/temp.log"
###    }
###    
###    set start_time [clock seconds]
###    if {[llength $prj] > 0} {
###       add_prj $prj
###       set end_time [clock seconds]
###       log_time add_prj $start_time $end_time 1 "Process PRJ file"
###    } else {
###       #### Read in System Verilog
###       if {[llength $sysvlog] > 0} {
###          add_sysvlog $sysvlog
###       }
###    
###       #### Read in Verilog
###       if {[llength $vlog] > 0} {
###          add_vlog $vlog
###       }
###    
###       #### Read in VHDL
###       if {[llength $vhdl] > 0} {
###          add_vhdl $vhdl
###       }
###       set end_time [clock seconds]
###       log_time add_files $start_time $end_time 1 "Add source files"
###    }
###       
###    #### Read IP from Catalog
###    if {[llength $ip] > 0} {
###       set start_time [clock seconds]
###       add_ip $ip
###       set end_time [clock seconds]
###       log_time add_ip $start_time $end_time 0 "Add XCI files and generate/synthesize IP"
###    }
###       
###    #### Read IPI systems
###    if {[llength $bd] > 0} {
###       set start_time [clock seconds]
###       add_bd $bd
###       set end_time [clock seconds]
###       log_time add_bd $start_time $end_time 0 "Add/generate IPI block design"
###    }
###    
###    #### Read in IP Netlists 
###    if {[llength $cores] > 0} {
###       set start_time [clock seconds]
###       add_cores $cores
###       set end_time [clock seconds]
###       log_time add_cores $start_time $end_time 0 "Add synthesized IP (DCP, NGC, EDIF)"
###    }
###    
###    #### Read in synthXDC files
###    if {[llength $synthXDC] > 0} {
###       set start_time [clock seconds]
###       add_xdc $synthXDC 2
###       set end_time [clock seconds]
###       log_time add_xdc $start_time $end_time 0 "Add synthesis only XDC files"
###    }
### 
###    #### Read in XDC file
###    if {[llength $xdc] > 0} {
###       set start_time [clock seconds]
###       add_xdc $xdc 1 
###       set end_time [clock seconds]
###       log_time add_xdc $start_time $end_time 0 "Add XDC files"
###    }
### 
###    if {[llength $xdc] == 0 && [llength $synthXDC] == 0} {
###       puts "\tInfo: No XDC file specified for $module"
###    }
### 
###    #### Set Verilog Headers 
###    if {[llength $vlogHeaders] > 0} {
###       foreach file $vlogHeaders {
###          command "set_property file_type {Verilog Header} \[get_files $file\]"
###       }
###    }
###    
###    #### Set Verilog Defines
###    if {$vlogDefines != ""} {
###       command "set_property verilog_define $vlogDefines \[current_fileset\]"
###    }
###    
###    #### Set Include Directories
###    if {$includes != ""} {
###       command "set_property include_dirs \"$includes\" \[current_fileset\]"
###    }
###    
###    #### Set Generics
###    if {$generics != ""} {
###       command "set_property generic $generics \[current_fileset\]"
###    }
###    
###    #### synthesis
###    puts "\tRunning synth_design"
###    set start_time [clock seconds]
###    if {$topLevel} {
###       command "synth_design -mode default $options -top $moduleName -part $part" "$resultDir/${moduleName}_synth_design.rds"
###    } else {
###       command "synth_design -mode out_of_context $options -top $moduleName -part $part" "$resultDir/${moduleName}_synth_design.rds"
###    }
###    set end_time [clock seconds]
###    log_time synth_design $start_time $end_time 0 "$moduleName $options"
###    
###    set start_time [clock seconds]
###    command "write_checkpoint -force $resultDir/${moduleName}_synth.dcp" "$resultDir/temp.log"
###    set end_time [clock seconds]
###    log_time write_checkpiont $start_time $end_time 0 "Write out synthesis DCP"
###    
###    if {$verbose >= 1} {
###       set start_time [clock seconds]
###       command "report_utilization -file $resultDir/${moduleName}_utilization_synth.rpt" "$resultDir/temp.log"
###       set end_time [clock seconds]
###       log_time report_utilization $start_time $end_time 0 "Report Synthesis Utilization of $module"
###    }
###    set synth_end [clock seconds]
###    log_time final $synth_start $synth_end
###    command "close_project"
###    command "puts \"#HD: Synthesis of module $module complete\\n\""
###    close $rfh
###    close $cfh
###    close $wfh
### }
## proc add_prj { prj } {
##    global srcDir
## 
##    if {[file exists $prj]} {
##       puts "\tParsing PRJ file: $prj"
##       set source [open $prj r]
##       set source_data [read $source]
##       close $source
##       #Remove quotes from PRJ file
##       regsub -all {\"} $source_data {} source_data
##       set prj_lines [split $source_data "\n" ]
##       set line_count 0
##       foreach line $prj_lines {
##          incr line_count
##          #Ignore empty and commented lines
##          if {[llength $line] > 0 && ![string match -nocase "#*" $line]} {
##             if {[llength $line]!=3} {
##                set errMsg "\nERROR: Line $line_count is invalid format. Should be:\n\t<file_type> <library> <file>"
##                error $errMsg
##             }
##             lassign $line type lib file
##             if {![string match -nocase $type "dcp"]     && \
##                 ![string match -nocase $type "xci"]     && \
##                 ![string match -nocase $type "header"]  && \
##                 ![string match -nocase $type "system"]  && \
##                 ![string match -nocase $type "verilog"] && \
##                 ![string match -nocase $type "vhdl"]} {
##                set errMsg "\nERROR: File type $type is not a supported value.\n"
##                append errMsg "Supported types are:\n\tdcp\n\txci\n\theader\n\tsystem\n\tverilog\n\tvhdl\n\t"
##                error $errMsg
##             }
##             if {[file exists ${srcDir}/$file]} {
##                set file ${srcDir}/$file
##                command "add_files $file" "add_files.log"
##                if {[string match -nocase $type "vhdl"]} {
##                   command "set_property LIBRARY $lib \[get_files $file\]"
##                }
##                if {[string match -nocase $type "system"]} {
##                   command "set_property FILE_TYPE SystemVerilog \[get_files $file\]"
##                }
##                if {[string match -nocase $type "header"]} {
##                    command "set_property FILE_TYPE {Verilog Header} \[get_files $file\]"
##                }
##             } elseif {[file exists $file]} {
##                command "add_files $file"
##                if {[string match -nocase $type "vhdl"]} {
##                   command "set_property LIBRARY $lib \[get_files $file\]"
##                }
##                if {[string match -nocase $type "system"]} {
##                   command "set_property FILE_TYPE SystemVerilog \[get_files $file\]"
##                }
##                if {[string match -nocase $type "header"]} {
##                    command "set_property FILE_TYPE {Verilog Header} \[get_files $file\]"
##                }
##             } else {
##                puts "ERROR: Could not find file \"$file\" on line $line_count."
##                set error 1
##             }
##          }
##       }
##       if {[info exists error]} {
##          set errMsg "\nERROR: Files not found. Check messages for more details.\n"
##          error $errMsg
##       }
##    } else {
##       set errMsg "\nERROR: Could not find PRJ file $prj"
##       error $errMsg
##    }
## }
## proc add_bd { files } {
##    upvar resultDir resultDir
## 
##    foreach file $files {
##       if {[string length file] > 0} { 
##          if {[file exists $file]} {
##             set bd_split [split $file "/"] 
##             set bd [lindex $bd_split end]
##             set bdName [lindex [split $bd "."] 0]
##             if {[regexp {.*\.tcl} $file]} {
##                command "source $file"
##                command "generate_target all \[get_files .srcs/sources_1/bd/${bdName}/${bdName}.bd\]"
##             } else {
##                command "add_files $file" "$resultDir/add_bd.log"
##                command "generate_target all \[get_files $file]" "$resultDir/${bdName}_generate.log"
##             }
##          } else {
##             set errMsg "\nERROR: Could not find specified BD file: $file" 
##             error $errMsg
##          }
##       }
##    }
## }
## proc add_sysvlog { sysvlog } {
##    set files [join $sysvlog]
##    foreach file $files {
##       if {[file exists $file]} {
##          command "add_files $file"
##          command "set_property FILE_TYPE SystemVerilog \[get_files $file\]"
##       } else {
##          puts "ERROR: Could not find file \"$file\"."
##          set error 1;
##       }
##    }
##    if {[info exists error]} {
##       set errMsg "\nERROR: Files not found. Check messages for more details.\n"
##       error $errMsg
##    }
## }
## proc add_vlog { vlog } {
##    set files [join $vlog]
##    foreach file $files {
##       if {[file exists $file]} {
##          command "add_files $file"
##       } else {
##          puts "ERROR: Could not find file \"$file\"."
##          set error 1;
##       }
##    }
##    if {[info exists error]} {
##       set errMsg "\nERROR: Files not found. Check messages for more details.\n"
##       error $errMsg
##    }
## }
## proc add_vhdl { vhdl } {
##    set index 0
##    while {$index < [llength $vhdl]} {
##       set lib [lindex $vhdl [expr $index+1]]
##       foreach file [lindex $vhdl $index] {
##          if {[file exists $file]} {
##             command "add_files $file"
##             command "set_property LIBRARY $lib \[get_files $file\]"
##          } else {
##             puts "ERROR: Could not find file \"$file\"."
##             set error 1;
##          }
##       }
##       set index [expr $index+2]
##    }
##    if {[info exists error]} {
##       set errMsg "\nERROR: Files not found. Check messages for more details.\n"
##       error $errMsg
##    }
## }
# source $tclDir/impl_utils.tcl
## if {[info exists tclDir]} {
##    source $tclDir/implement.tcl
##    source $tclDir/step.tcl
## }
### proc implement {impl} {
###    global tclParams 
###    global part
###    global dcpLevel
###    global verbose
###    global implDir
###    global xdcDir
###    global dcpDir
###    global RFH
### 
###    set top                 [get_attribute impl $impl top]
###    set name                [get_attribute impl $impl name]
###    set implXDC             [get_attribute impl $impl implXDC]
###    set linkXDC             [get_attribute impl $impl linkXDC]
###    set cores               [get_attribute impl $impl cores]
###    set ip                  [get_attribute impl $impl ip]
###    set ipRepo              [get_attribute impl $impl ipRepo]
###    set hd                  [get_attribute impl $impl hd.impl]
###    set td                  [get_attribute impl $impl td.impl]
###    set pr                  [get_attribute impl $impl pr.impl]
###    set ic                  [get_attribute impl $impl ic.impl]
###    set incr                [get_attribute impl $impl incr.impl]
###    set iso                 [get_attribute impl $impl iso.impl]
###    set ooc                 [get_attribute impl $impl ooc.impl]
###    set pr.budget           [get_attribute impl $impl pr.budget]
###    set budgetExclude       [get_attribute impl $impl pr.budget_exclude]
###    set partitions          [get_attribute impl $impl partitions]
###    set link                [get_attribute impl $impl link]
###    set opt                 [get_attribute impl $impl opt]
###    set opt.pre             [get_attribute impl $impl opt.pre]
###    set opt_options         [get_attribute impl $impl opt_options]
###    set opt_directive       [get_attribute impl $impl opt_directive]
###    set place               [get_attribute impl $impl place]
###    set place.pre           [get_attribute impl $impl place.pre]
###    set place_options       [get_attribute impl $impl place_options]
###    set place_directive     [get_attribute impl $impl place_directive]
###    set phys                [get_attribute impl $impl phys]
###    set phys.pre            [get_attribute impl $impl phys.pre]
###    set phys_options        [get_attribute impl $impl phys_options]
###    set phys_directive      [get_attribute impl $impl phys_directive]
###    set route               [get_attribute impl $impl route]
###    set route.pre           [get_attribute impl $impl route.pre]
###    set route_options       [get_attribute impl $impl route_options]
###    set route_directive     [get_attribute impl $impl route_directive]
###    set bitstream           [get_attribute impl $impl bitstream]
###    set bitstream.pre       [get_attribute impl $impl bitstream.pre]
###    set bitstream_options   [get_attribute impl $impl bitstream_options]
###    set bitstream_settings  [get_attribute impl $impl bitstream_settings]
###    set drc.quiet           [get_attribute impl $impl drc.quiet]
### 
###    if {($hd && ($td || $ic || $pr || $ooc)) || \
###        ($td && ($hd || $ic || $pr || $ooc)) || \
###        ($ic && ($td || $hd || $pr || $ooc)) || \
###        ($pr && ($td || $hd || $ic || $ooc)) || \
###        ($ooc && ($td || $hd || $ic || $pr)) } {
###       set errMsg "\nERROR: Implementation $impl has more than one of the following flow variables set to 1"
###       append errMsg "\n\thd.impl($hd)\n\ttd.impl($td)\n\tic.impl($ic)\n\tpr.impl($pr)\n\t$ooc.impl($ooc)\n"
###       append errMsg "Only one of these variables can be set true at one time. To run multiple flows, create separate implementation runs."
###       error $errMsg
###    }
### 
###    set resultDir "$implDir/$impl"
###    set reportDir "$resultDir/reports"
### 
###    #### Make the implementation directory, Clean-out and re-make the results directory
###    command "file mkdir $implDir"
###    command "file delete -force $resultDir"
###    command "file mkdir $resultDir"
###    command "file mkdir $reportDir"
###    
###    #### Open local log files
###    set rfh [open "$resultDir/run.log" w]
###    set cfh [open "$resultDir/command.log" w]
###    set wfh [open "$resultDir/critical.log" w]
### 
###    set vivadoVer [version]
###    puts $rfh "Info: Running Vivado version $vivadoVer"
###    puts $RFH "Info: Running Vivado version $vivadoVer"
### 
###    command "puts \"#HD: Running implementation $impl\""
###    puts "\tWriting results to: $resultDir"
###    puts "\tWriting reports to: $reportDir"
###    puts $rfh "#HD: Running implementation $impl"
###    puts $rfh "Writing results to: $resultDir"
###    puts $rfh "Writing reports to: $reportDir"
###    puts $RFH "#HD: Running implementation $impl"
###    puts $RFH "Writing results to: $resultDir"
###    puts $RFH "Writing reports to: $reportDir"
###    set impl_start [clock seconds]
### 
###    #### Set Tcl Params
###    if {[info exists tclParams] && [llength $tclParams] > 0} {
###       set_parameters $tclParams
###    }
### 
###    #### Create in-memory project
###    command "create_project -in_memory -part $part" "$resultDir/create_project.log"
###    
###    #### Setup any IP Repositories 
###    if {$ipRepo != ""} {
###       puts "\tLoading IP Repositories:\n\t+ [join $ipRepo "\n\t+ "]"
###       command "set_property IP_REPO_PATHS \{$ipRepo\} \[current_fileset\]" "$resultDir/temp.log"
###       command "update_ip_catalog" "$resultDir/temp.log"
###    }
### 
###    ###########################################
###    # Linking
###    ###########################################
###    if {$link} {
###       #Determine state of Top (import or implement). 
###       set topState "implement"
###       foreach partition $partitions {
###          lassign $partition module cell state name type level dcp
###          if {[string match $cell $top]} {
###             set topState $state 
###             if {[llength $dcp]} {
###                set topFile $dcp
###             }
###          }
###       }
### 
###       #If DCP for top is not defined in Partition settings, try and find it.
###       if {![info exist topFile] || ![llength $topFile]} {
###          foreach module [get_modules] {
###             set moduleName [get_attribute module $module moduleName]
###             if {[string match $top $moduleName]} {
###                break
###             }
###          }
###          if {[string match $topState "implement"]} {
###             set topFile [get_module_file $module]
###          } elseif {[string match $topState "import"]} {
###             if {$pr} {
###                set topFile "$dcpDir/${top}_static.dcp"
###             } else {
###                set topFile "$dcpDir/${top}_routed.dcp"
###             }
###          } else {
###             set errMsg "\nERROR: State of Top module $top is set to illegal state $topState." 
###             error $errMsg
###          }
###       }
### 
###       puts "\t#HD: Adding file $topFile for $top"
###       if {[info exists topFile]} {
###          command "add_files $topFile"
###       } else {
###          set errMsg "\nERROR: Specified file $topFile cannot be found on disk. Verify path is correct." 
###          error $errMsg
###       }
###    
###       ####Read in top-level cores, ip,  and XDC on if Top is being implemented
###       if {[string match $topState "implement"]} { 
###          # Read in IP Netlists 
###          if {[llength $cores] > 0} {
###             add_cores $cores
###          }
###          # Read IP XCI files
###          if {[llength $ip] > 0} {
###             set start_time [clock seconds]
###             add_ip $ip
###             set end_time [clock seconds]
###             log_time add_ip $start_time $end_time 0 "Add XCI files and generate/synthesize IP"
###          }
###          # Read in XDC files
###          if {[llength $implXDC] > 0 && [string match $topState "implement"]} {
###             add_xdc $implXDC
###          } else {
###             if {[string match $topState "import"]} {
###                puts "\tInfo: Skipping top-level XDC files because $top is set to $topState"
###             } else {
###                puts "\tInfo: No pre-link_design XDC file specified for $impl"
###             }
###          }
###       }
###    
###       ###########################################################
###       # Link the top-level design with black boxes for Partitions 
###       ###########################################################
###       set start_time [clock seconds]
###       if {!$ooc} {
###          puts "\t#HD: Running link_design for $top \[[clock format $start_time -format {%a %b %d %H:%M:%S %Y}]\]"
###          command "link_design -mode default -part $part -top $top" "$resultDir/${top}_link_design.log"
###       } else {
###          puts "\t#HD: Running link_design for $top \[[clock format $start_time -format {%a %b %d %H:%M:%S %Y}]\]"
###          command "link_design -mode out_of_context -part $part -top $top" "$resultDir/${top}_link_design.log"
###          #Set appropriate attribute on "current_design" for ISO and OOC flows.
###          if {$iso} {
###             command "set_property HD.ISOLATED 1 \[current_design]"
###          } else {  
###             command "set_property HD.PARTITION 1 \[current_design]"
###          }
###       }
###       set end_time [clock seconds]
###       log_time link_design $start_time $end_time 1 "link_design -part $part -top $top"
### 
###       ##############################################
###       # Resolve Partitions 
###       ##############################################
###       #Special processing for TopDown implementation
###       if {$td && $verbose > 0} {
###          #Turn off phys_opt_design and route_design for TD run
###          set phys  [set_attribute impl $impl phys  0]
###          set route [set_attribute impl $impl route 0]
###          #Turn on param to generate PP_RANGE if one does not exist
###          set_parameters {hd.partPinRangesForPblock 1} 
###       }
### 
###       foreach partition $partitions {
###          lassign $partition module cell state name type level dcp
###          if {![llength $name]} {
###             set name [lindex [split $cell "/"] end]
###          }
### 
###          #Process each partition that is not Top
###          set moduleName [get_attribute module $module moduleName]
###          if {![string match $moduleName $top]} {
###             #Set appropriate HD.* property if Top/Static is being implemented
###             if {[string match $topState "implement"]} {
###                #Mark all partitions as HD.RECONFIG in a PR run unless partition 'type' is set to OOC
###                if {$pr && ![string match $type "ooc"] && ![string match $type "iso"]} {
###                   command "set_property HD.RECONFIGURABLE 1 \[get_cells $cell]"
###                } elseif [string match $type "iso"] {
###                   command "set_property HD.ISOLATED 1 \[get_cells $cell]"
###                } else {
###                   command "set_property HD.PARTITION 1 \[get_cells $cell]"
###                }
###             }
### 
###             #Find correct file to be used for Partition
###             if {[llength $dcp] && ![string match $state "greybox"]} {
###                set partitionFile $dcp
###             } else {
###                #Greybox overrides any other settings regardless of flow
###                if {[string match $state "greybox"]} {
###                   puts "\tInfo: Cell $cell will be implemented as a grey box."
###                   set partitionFile "NA"
###                #if flow is incremental, load synth netlist regardless of $state equal to import Vs implement
###                } elseif {[string match $state "implement"] || $incr} {
###                   set partitionFile [get_module_file $module]
###                } elseif {[string match $state "import"]} {
###                   if {$iso || $ooc} {
###                      set partitionFile "$dcpDir/${pblock}_${module}_route_design.dcp"
###                   } else {
###                      set pblock [get_pblock -of [get_cell $cell]]
###                      #Since names rely on Pblock to uniquify, error if no Pblock exists.
###                      if {![llength $pblock]} {
###                         set errMsg "Error: No pblock found on partition cell $cell."
###                         error $errMsg
###                      }
###                      set partitionFile "$dcpDir/${pblock}_${module}_route_design.dcp"
###                   }
###                } else {
###                   set errMsg "\nERROR: Invalid state \"$state\" in settings for $name\($impl)."
###                   append errMsg"Valid states are \"implement\", \"import\", or \"greybox\".\n" 
###                   error $errMsg
###                }
###             }
###             if {![file exists $partitionFile] && ![string match $state "greybox"]} {
###                set errMsg "ERROR: Partition \'$cell\' with state \'$state\' is set to use the file:\n$partitionFile\n\nThis file does not exist."
###                if {$ooc} {
###                   append errMsg "Check that the Name of the parition matches the Name field of the corresponding OOC run."
###                }
###                error $errMsg
###             }
### 
###             #Resolve blackbox for partition
###             if {![get_property IS_BLACKBOX [get_cells $cell]]} {
###                set start_time [clock seconds]
###                puts "\tCritical Warning: Partition cell \'$cell\' is not a blackbox. This likely occurred because OOC synthesis was not used. This can cause illegal optimization. Please verify it is intentional that this cell is not a blackbox at this stage in the flow.\nResolution: Caving out cell to make required blackbox. \[[clock format $start_time -format {%a %b %d %H:%M:%S %Y}]\]"
###                command "update_design -cells $cell -black_box" "$resultDir/update_design_blackbox_$name.log"
###                set end_time [clock seconds]
###                log_time update_design $start_time $end_time 0 "Create blackbox for $name"
###             }
###             if {[string match $state "greybox"]} {
###                command "set_msg_config -id \"Constraints 18-514\" -suppress"
###                command "set_msg_config -id \"Constraints 18-515\" -suppress"
###                command "set_msg_config -id \"Constraints 18-402\" -suppress"
###                set start_time [clock seconds]
###                puts "\t#HD: Inserting LUT1 buffers on interface of $name \[[clock format $start_time -format {%a %b %d %H:%M:%S %Y}]\]"
###                command "update_design -cells $cell -buffer_ports" "$resultDir/update_design_bufferport_$name.log"
###                set end_time [clock seconds]
###                log_time update_design $start_time $end_time 0 "Buffer blackbox RM $name"
###                #If verbose it turned up, write out intermediate link_design DCP files
###                if {$dcpLevel > 1} {
###                   set start_time [clock seconds]
###                   command "write_checkpoint -force $resultDir/${top}_link_design_intermediate.dcp" "$resultDir/temp.log"
###                   set end_time [clock seconds]
###                   log_time write_checkpoint $start_time $end_time 0 "Intermediate link_design checkpoint for debug"
###                }
###                set budgetXDC $xdcDir/${name}_budget.xdc
###                if {![file exists $budgetXDC] || ${pr.budget}} {
###                   set start_time [clock seconds]
###                   puts "\t#HD: Creating budget constraints for greybox $name \[[clock format $start_time -format {%a %b %d %H:%M:%S %Y}]\]"
###                   create_pr_budget -cell $cell -file $budgetXDC -exclude $budgetExclude
###                   set end_time [clock seconds]
###                   log_time create_budget $start_time $end_time 0 "Create budget constraints for $name"
###                }
###                set start_time [clock seconds]
###                readXDC $budgetXDC
###                set end_time [clock seconds]
###                log_time read_xdc $start_time $end_time 0 "Read in budget constraints for $name"
###             } else {
###                set fileSplit [split $partitionFile "."]
###                set fileType [lindex $fileSplit end]
###                if {[string match $fileType "dcp"]} {
###                   set start_time [clock seconds]
###                   puts "\tReading in checkpoint $partitionFile for $cell ($module) \[[clock format $start_time -format {%a %b %d %H:%M:%S %Y}]\]"
###                   command "read_checkpoint -cell $cell $partitionFile -strict" "$resultDir/read_checkpoint_${module}_${name}.log"
###                   set end_time [clock seconds]
###                   log_time read_checkpoint $start_time $end_time 0 "Resolve blackbox for $name"
###                } elseif {[string match $fileType "edf"] || [string match $fileType "edn"]} {
###                   set start_time [clock seconds]
###                   puts "\tUpdating design with $partitionFile for $cell ($module) \[[clock format $start_time -format {%a %b %d %H:%M:%S %Y}]\]"
###                   command "update_design -cells $cell -from_file $partitionFile" "$resultDir/update_design_$name.log"
###                   set end_time [clock seconds]
###                   log_time update_design $start_time $end_time 0 "Resolve blackbox for $name"
###                } else {
###                   set errMsg "\nERROR: Invalid file type \"$fileType\" for $partitionFile.\n"
###                   error $errMsg
###                }
###             }
###    
###             #Read in Module XDC if module is not imported
###             if {![string match $state "import"]} { 
###                ## Read in module Impl XDC files 
###                set implXDC [get_attribute module $module implXDC]
###                if {[llength $implXDC] > 0} {
###                   set start_time [clock seconds]
###                   readXDC $implXDC
###                   set end_time [clock seconds]
###                   log_time read_xdc $start_time $end_time 0 "Cell level XDCs for $name"
###                } else {
###                   puts "\tInfo: No cell XDC file specified for $cell"
###                }
###             }
###    
###             #Lock imported Partitions
###             if {[string match $state "import"] && !$incr} {
###                if {![llength $level]} {
###                   set level "routing"
###                }
###                set start_time [clock seconds]
###                puts "\tLocking $cell \[[clock format $start_time -format {%a %b %d %H:%M:%S %Y}]\]"
###                command "lock_design -level $level $cell" "$resultDir/lock_design_$name.log"
###                set end_time [clock seconds]
###                log_time lock_design $start_time $end_time 0 "Locking cell $cell at level routing"
###             }
###    
###             #Do up front check for PR for Pblocks on Partitions
###             if {$verbose && $pr} {
###                set rpPblock [get_pblocks -quiet -of [get_cells $cell]]
###                if {![llength $rpPblock]} {
###                   set errMsg "ERROR: No pblock found for PR cell $cell."
###                   #error $errMsg
###                }
###             }
### 
###             #Create constraints for OOC partitions if TopDown run.
###             if {$td && [string match $type "ooc"]} {
###                puts "\t#HD: Creating OOC constraints for $cell"
###                set start_time [clock seconds]
###                create_set_logic $name $cell $xdcDir
###                create_ooc_clocks $name $cell $xdcDir
###                set end_time [clock seconds]
###                log_time "create_constraints" $start_time $end_time 0 "Create necessary OOC constraints"
###             }
### 
###             #If verbose it turned up, write out intermediate link_design DCP files
###             if {$dcpLevel > 1} {
###                set start_time [clock seconds]
###                command "write_checkpoint -force $resultDir/${top}_link_design_intermediate.dcp" "$resultDir/temp.log"
###                set end_time [clock seconds]
###                log_time write_checkpoint $start_time $end_time 0 "Intermediate link_design checkpoint for debug"
###             }
###          }; #End: Process each partition that is not Top
###       }
### 
###       ##############################################
###       # Read in any linkXDC files 
###       ##############################################
###       #if {[llength $linkXDC] > 0 && [string match $topState "implement"]} {}
###       if {[llength $linkXDC] > 0 } {
###          set start_time [clock seconds]
###          readXDC $linkXDC
###          set end_time [clock seconds]
###          log_time read_xdc $start_time $end_time 0 "Post link_design XDC files"
###       } else {
###          puts "\tInfo: No post-link_design XDC file specified for $impl"
###       }
### 
###       if {$dcpLevel > 0} {
###          set start_time [clock seconds]
###          command "write_checkpoint -force $resultDir/${top}_link_design.dcp" "$resultDir/temp.log"
###          set end_time [clock seconds]
###          log_time write_checkpoint $start_time $end_time 0 "Post link_design checkpoint"
###       }
### 
### 
###       ##############################################
###       # Write out final link_design DCP 
###       ##############################################
###       if {$verbose > 1} {
###          set start_time [clock seconds]
###          command "report_utilization -file $reportDir/${top}_utilization_link_design.rpt" "$resultDir/temp.log"
###          set end_time [clock seconds]
###          log_time report_utilization $start_time $end_time
###       } 
###       puts "\t#HD: Completed link_design"
###       puts "\t##########################\n"
### 
###       if {$incr} {
###          set imports {}
###          foreach partition $partitions {
###             lassign $partition module cell state name type level dcp
###             #Process each partition that is not Top
###             set moduleName [get_attribute module $module moduleName]
###             if {![string match $moduleName $top]} {
###                if {[string match $state "import"]} {
###                   lappend imports $cell
###                }
###             }
###          }
###          if {[llength $imports]} {
###             set start_time [clock seconds]
###             command "read_checkpoint -incremental -only_reuse \{$imports\} $dcpDir/${top}_incremental.dcp" "$resultDir/read_incremental.log"
###             set end_time [clock seconds]
###             log_time read_checkpoint $start_time $end_time 0 "Read incremental Checkpoint for $imports"
###          }
###       }
### 
###       ##############################################
###       # Run Methodology DRCs checks 
###       ##############################################
###       #Run methodology DRCs and catch any Critical Warnings or Error (module ruledeck quiet)
###       if {$verbose > 1} {
###          set start_time [clock seconds]
###          check_drc $top methodology_checks 1
###          set end_time [clock seconds]
###          log_time report_drc $start_time $end_time 0 "methodology checks"
###          #Run timing DRCs and catch any Critical Warnings or Error (module ruledeck quiet)
###          set start_time [clock seconds]
###          check_drc $top timing_checks 1
###          set end_time [clock seconds]
###          log_time report_drc $start_time $end_time 0 "timing_checks"
###       }
###    }
### 
### #COPIED from OLD ooc_impl.tcl.  STILL NEEDED?
###    #if OOC Create timing budget constraints for the interface ports based on a percentage of the full period
###    #if {$ooc && ${budget.create}} {
###    #   set budgetXDC "${top}_ooc_budget.xdc"
###    #   puts "\tWriting inteface budgets constraints to XDC file \"$xdcDir/$budgetXDC\"."
###    #   command "::debug::gen_hd_timing_constraints -percent ${budget.percent} -file $xdcDir/$budgetXDC"
###    #   puts "\tReading XDC file $xdcDir/$budgetXDC"
###    #   command "read_xdc -mode out_of_context $xdcDir/$budgetXDC" "$resultDir/read_xdc_${ooc_inst}_budget.log"
###    #} 
###    ############################################################################################
###    # Implementation steps: opt_design, place_design, phys_opt_design, route_design
###    ############################################################################################
###    if {$opt} {
###       impl_step opt_design $top $opt_options $opt_directive ${opt.pre}
###    }
### 
###    if {$place} {
###       #Report out all RM clocks for PR runs
###       if {$pr} {
###          foreach partition $partitions {
###             lassign $partition module cell state name type level dcp
###             if {![string match $cell $top]} {
###                if {![llength $name]} {
###                   set name [lindex [split $cell "/"] end]
###                }
###                get_rp_clocks $cell $reportDir/${name}_clocks.rpt
###             }
###          }
###       }
###       impl_step place_design $top $place_options $place_directive ${place.pre}
### 
###       #### If Top-Down, write out XDCs 
###       if {$td && $verbose > 0} {
###          puts "\n\tWriting instance level XDC files."
###          foreach partition $partitions {
###             lassign $partition module cell state name type level dcp
###             if {![string match $cell $top]} {
###                if {![llength $name]} {
###                   set name [lindex [split $cell "/"] end]
###                }
###                write_hd_xdc $name $cell $xdcDir
###             }
###          }
###       }
###    }
### 
###    if {$phys} {
###       impl_step phys_opt_design $top $phys_options $phys_directive ${phys.pre}
###    }
### 
###    if {$route} {
###       impl_step route_design $top $route_options $route_directive ${route.pre}
###  
###       #Run report_timing_summary on final design
###       set start_time [clock seconds]
###       command "report_timing_summary -delay_type min_max -report_unconstrained -check_timing_verbose -max_paths 10 -input_pins -file $reportDir/${top}_timing_summary.rpt" "$resultDir/temp.log"
###       set end_time [clock seconds]
###       log_time report_timing $start_time $end_time 0 "Timing Summary"
###    
###       #Run a final DRC that catches any Critical Warnings (module ruledeck quiet)
###       set start_time [clock seconds]
###       if {$ooc} {
###          check_drc $top default ${drc.quiet}
###       } else {
###          check_drc $top bitstream_checks ${drc.quiet}
###       }
### 
###       set end_time [clock seconds]
###       log_time report_drc $start_time $end_time 0 "bistream_checks"
###    
###       #Report PR specific statitics for debug and analysis
###       if {$pr} {
###          command "debug::report_design_status" "$reportDir/${top}_design_status.rpt"
###       }
###    }
###    
###    if {![file exists $dcpDir]} {
###       command "file mkdir $dcpDir"
###    }   
### 
###    #Write out checkpoints for OOC implementations
###    if {$iso || $ooc} {
###       set pblock [get_pblocks -filter PARENT==ROOT]
###       set dcp "$resultDir/${top}_route_design.dcp"
###       command "file copy -force $dcp $dcpDir/${pblock}_${top}_route_design.dcp"
###    }
###  
###    if {$ic || $pr} {
###       #Write out cell checkpoints for all Partitions and create black_box 
###       foreach partition $partitions {
###          lassign $partition module cell state name type level dcp
###          set moduleName [get_attribute module $module moduleName]
###          if {![string match $moduleName $top] && ([string match $state "implement"] || [string match $topState "implement"])} {
###             if {![llength $name]} {
###                set name [lindex [split $cell "/"] end]
###             }
###             set start_time [clock seconds]
###             set pblock [get_pblock -of [get_cells $cell]]
###             #Pblock required to generate unique name. Do not write out cell DCP if not Pblock exists.
###             if {[llength $pblock]} {
###                set dcp "$resultDir/${pblock}_${module}_route_design.dcp"
###                command "write_checkpoint -force -cell $cell $dcp" "$resultDir/temp.log"
###                set end_time [clock seconds]
###                log_time write_checkpoint $start_time $end_time 0 "Write cell checkpoint for $cell"
###                command "file copy -force $dcp $dcpDir"
###             } else {
###                puts "Critical Warning: No pblock found for $cell. No cell-level DCP will be written out."
###             }
###             if {[string match $topState "implement"]} {
###                set start_time [clock seconds]
###                puts "\tCarving out $cell to be a black box \[[clock format $start_time -format {%a %b %d %H:%M:%S %Y}]\]"
###                command "update_design -cell $cell -black_box" "$resultDir/carve_$name.log"
###                set end_time [clock seconds]
###                log_time update_design $start_time $end_time 0 "Carve out (blackbox) $cell"
###             }
###          }
###       }
### 
###       #Write out implemented version of Top for import in subsequent runs
###       foreach partition $partitions {
###          lassign $partition module cell state name type level dcp
###          set moduleName [get_attribute module $module moduleName]
###          set name [lindex [split $cell "/"] end]
###          if {[string match $moduleName $top] && [string match $state "implement"]} {
###             set start_time [clock seconds]
###             puts "\tLocking $top and exporting results \[[clock format $start_time -format {%a %b %d %H:%M:%S %Y}]\]"
###             command "lock_design -level routing" "$resultDir/lock_design_$top.log"
###             set end_time [clock seconds]
###             log_time lock_design $start_time $end_time 0 "Lock placement and routing of $top"
###             if {$pr} {
###                set topDCP "$resultDir/${top}_static.dcp"
###             } else {
###                set topDCP "$resultDir/${top}_routed.dcp"
###             }
###             set start_time [clock seconds]
###             command "write_checkpoint -force $topDCP" "$resultDir/temp.log"
###             command "file copy -force $topDCP $dcpDir"
###             set end_time [clock seconds]
###             log_time write_checkpoint $start_time $end_time 0 "Write out locked Static checkpoint"
###          }
###       }
###    }
### 
###    #For incremental flow, lock all implemented partitions and write out an "incremental" DCP
###    if {$incr} {
###       foreach partition $partitions {
###          lassign $partition module cell state name type level dcp
###          set moduleName [get_attribute module $module moduleName]
###          if {![string match $moduleName $top]} {
###             if {[string match $state "implement"]} {
###                set start_time [clock seconds]
###                puts "\t#HD: Locking $cell \[[clock format $start_time -format {%a %b %d %H:%M:%S %Y}]\]"
###                command "lock_design -level routing $cell" "$resultDir/lock_design_incremental.log"
###                set end_time [clock seconds]
###             }
###          }
###       }
###       set start_time [clock seconds]
###       command "write_checkpoint -force $resultDir/${top}_incremental.dcp" "$resultDir/temp.log"
###       command "file copy -force $resultDir/${top}_incremental.dcp $dcpDir"
###       set end_time [clock seconds]
###       log_time write_checkpoint $start_time $end_time 0 "Write out locked incremental checkpoint"
###    }
### 
###    #For PR, don't write out bitstreams until after PR_VERIFY has run. See run.tcl
###    if {$bitstream && !$pr} {
###       impl_step write_bitstream $top $bitstream_options none ${bitstream.pre} $bitstream_settings
###    }
###    
###    #For ISO flow, disable DRCs so that OOC bitstream can be written
###    if {$iso && $bitstream} {
###       command "set_property IS_ENABLED {false} \[get_drc_checks\]"
###       impl_step write_bitstream $ooc_inst $bitstream_options none ${bitstream.pre}
###       command "reset_drc_check \[get_drc_checks]"
###    }
###  
###    #Turn path segmentation message back on if any partitions were a greybox.
###    foreach partition $partitions {
###       lassign $partition module cell state name type level dcp
###       if {[string match $state "greybox"]} {
###          command "reset_msg_config -quiet -id \"Constraints 18-514\" -suppress"
###          command "reset_msg_config -quiet -id \"Constraints 18-515\" -suppress"
###          command "reset_msg_config -quiet -id \"Constraints 18-402\" -suppress"
###          break
###       }
###    }
### 
###    set impl_end [clock seconds]
###    log_time final $impl_start $impl_end 
###    log_data $impl $top
### 
###    command "close_project"
###    command "puts \"#HD: Implementation $impl complete\\n\""
###    close $rfh
###    close $cfh
###    close $wfh
### }
### proc impl_step {phase instance {options none} {directive none} {pre none} {settings none} } {
###    global dcpLevel
###    global verbose
###    upvar  resultDir resultDir
###    upvar  reportDir reportDir
### 
###    #Make sure $phase is valid and set checkpoint in case no design is open
###    if {[string match $phase "opt_design"]} {
###       set checkpoint1 "$resultDir/${instance}_link_design.dcp"
###    } elseif {[string match $phase "place_design"]} {
###       set checkpoint1 "$resultDir/${instance}_opt_design.dcp"
###    } elseif {[string match $phase "phys_opt_design"]} {
###       set checkpoint1 "$resultDir/${instance}_place_design.dcp"
###    } elseif {[string match $phase "route_design"]} {
###       set checkpoint1 "$resultDir/${instance}_phys_opt_design.dcp"
###       set checkpoint2 "$resultDir/${instance}_place_design.dcp"
###    } elseif {[string match $phase "write_bitstream"]} {
###       set checkpoint1 "$resultDir/${instance}_route_design.dcp"
###    } else {
###       set errMsg "\nERROR: Value $phase is not a recognized step of implementation. Valid values are \"opt_design\", \"place_design\", \"phys_opt_design\", or \"route_design\"."
###       error $errMsg
###    }
###    #If no design is open
###    if { [catch {current_instance > $resultDir/temp.log} errMsg] && $verbose > 0 } {
###       puts "\tNo open design" 
###       if {[info exists checkpoint1] || [info exists checkpoint2]} {
###          if {[file exists $checkpoint1]} {
###             puts "\tOpening checkpoint $checkpoint1 for $instance"
###             command "open_checkpoint $checkpoint1" "$resultDir/open_checkpoint_${instance}_$phase.log"
###             if { [catch {current_instance > $resultDir/temp.log} errMsg] } {
###                command "link_design"
###             }
###          } elseif {[file exists $checkpoint2]} {
###             puts "\tOpening checkpoint $checkpoint2 for $instance"
###             command "open_checkpoint $checkpoint2" "$resultDir/open_checkpoint_${instance}_$phase.log"
###             if { [catch {current_instance > $resultDir/temp.log} errMsg] } {
###                command "link_design"
###             }
###          } else {
###             set errMsg "\nERROR: Checkpoint file not found. Please rerun necessary steps."
###             error $errMsg
###          }
###       } else {
###         set errMsg "\nERROR: No checkpoint defined."
###         error $errMsg
###       }
###    }
###   
###    #Run any specified pre-phase scripts
###    if {![string match $pre "none"] && ![string match $pre ""] } {
###       foreach script $pre {
###          if {[file exists $script]} {
###             puts "\t#HD: Running pre-$phase script $script"
###             command "source $script" "$resultDir/pre_${phase}_script.log"
###          } else {
###             set errMsg "\nERROR: Script $script specified for pre-${phase} does not exist"
###             error $errMsg
###          }
###       }
###    }
###  
###    #Append options or directives to command
###    if {[string match $phase "write_bitstream"]} {
###       set impl_step "$phase -force -file $resultDir/$instance"
###    } else {
###       set impl_step $phase
###    }
### 
###    if {[string match $options "none"]==0 && [string match $options ""]==0} {
###       append impl_step " $options"
###    }
###    if {[string match $directive "none"]==0 && [string match $directive ""]==0} {
###       append impl_step " -directive $directive"
###    }
###    if {[string match $settings "none"]==0 && [string match $settings ""]==0} {
###       foreach setting $settings {
###          puts "\tSetting property $setting"
###          command "set_property $setting \[current_design]"
###       }
###    }
### 
###    #Run the specified Implementation phase
###    puts "\n\t#HD: Running $impl_step for $instance"
### 
###    set log "$resultDir/${instance}_$phase.log"
###    puts "\tWriting Results to $log"
### 
###    set start_time [clock seconds]
###    puts "\t$phase start time: \[[clock format $start_time -format {%a %b %d %H:%M:%S %Y}]\]"
###    command "$impl_step" "$log"
###    set end_time [clock seconds]
###    log_time $phase $start_time $end_time 0 "$impl_step" 
###    command "puts \"\t#HD: Completed: $phase\""
###    puts "\t################################"
###       
###    #Write out checkpoint for successfully completed phase
###    if {($dcpLevel > 0 || [string match $phase "route_design"]) && ![string match $phase "write_bitstream"]} {
###       set start_time [clock seconds]
###       puts "\tWriting post-$phase checkpoint: $resultDir/${instance}_$phase.dcp \[[clock format $start_time -format {%a %b %d %H:%M:%S %Y}]\]\n"
###       command "write_checkpoint -force $resultDir/${instance}_$phase.dcp" "$resultDir/temp.log"
###       set end_time [clock seconds]
###       log_time write_checkpoint $start_time $end_time 0 "Post-$phase checkpoint"
###    }
### 
###    #Write out additional reports controled by verbose level
###    if {$verbose > 1 || [string match $phase "route_design"]} {
###       set start_time [clock seconds]
###       command "report_utilization -file $reportDir/${instance}_utilization_${phase}.rpt" "$resultDir/temp.log"
###       log_time report_utilization $start_time $end_time
###    }
###    if {[string match $phase "route_design"]} {
###       set start_time [clock seconds]
###       command "report_route_status -file $reportDir/${instance}_route_status.rpt" "$resultDir/temp.log"
###       set end_time [clock seconds]
###       log_time report_route_status $start_time $end_time
###    }
### }
## proc get_module_file { module } {
##    global synthDir
##    global netlistDir
##    
##    if {![info exists synthDir]} {
##       set synthDir "."
##    }
##    if {![info exists netlistDir]} {
##       set netlistDir "."
##    }
## 
##    set moduleName [get_attribute module $module moduleName]
##    set synthDCP   [get_attribute module $module synthCheckpoint]
##    set searchFiles [list $synthDCP \
##                          $synthDir/$module/${moduleName}_synth.dcp  \
##                          $netlistDir/$module/${moduleName}.edf      \
##                          $netlistDir/$module/${moduleName}.edn      \
##                          $netlistDir/$module/${moduleName}.ngc      \
##                    ]
##    set moduleFile ""
##    foreach file $searchFiles {
##       if {[file exists $file]} {
##          set moduleFile $file
##          break
##       }
##    } 
##    if {![llength $moduleFile]} {
##       set errMsg "\nERROR: No synthesis netlist or checkpoint file found for $module."
##       append errMsg "\nSearched directories:"
##       foreach file $searchFiles {
##          append errMsg "\t$file\n"
##       }
##       error $errMsg
##    }
##    return $moduleFile
## }
## proc get_ooc_results { implementations } {
##    global dcpLevel
##    upvar resultDir resultDir
## 
##    foreach ooc $implementations {
##       set instName       [get_attribute ooc $ooc inst]
##       set hierInst       [get_attribute ooc $ooc hierInst]
##       set readCheckpoint [get_attribute ooc $ooc implCheckpoint]
##       set preservation   [get_attribute ooc $ooc preservation]
##       set hd.isolated    [get_attribute ooc $ooc hd.isolated]
## 
##       if {![file exists $readCheckpoint]} {
##          set errMsg "\nERROR: Specified OOC Checkpoint $readCheckpoint does not exist."
##          error $errMsg
##       }
## 
##       if {[get_property IS_BLACKBOX [get_cells $hierInst]]} {
##          set start_time [clock seconds]
##          puts "\tReading in checkpoint $readCheckpoint for $instName \[[clock format $start_time -format {%a %b %d %H:%M:%S %Y}]\]"
##          if {${hd.isolated}} {
##             command "set_property HD.ISOLATED 1 \[get_cells $hierInst]"
##          } else {
##             command "set_property HD.PARTITION 1 \[get_cells $hierInst]"
##          }
##          command "read_checkpoint -cell $hierInst $readCheckpoint -strict" "$resultDir/read_checkpoint_${instName}.log"
##          set end_time [clock seconds]
##          log_time read_checkpoint $start_time $end_time 0 "Resolve blacbox for $instName"
##          if {[string match $preservation "logical"  ] || \
##              [string match $preservation "placement"] || \
##              [string match $preservation "routing"  ]} {
##             set start_time [clock seconds]
##             puts "\tLocking $hierInst \[[clock format $start_time -format {%a %b %d %H:%M:%S %Y}]\]"
##             command "lock_design -level $preservation $hierInst" "$resultDir/lock_design_$instName.log"
##             set end_time [clock seconds]
##             log_time lock_design $start_time $end_time 0 "Locking cell $hierInst at level $preservation"
##          } elseif {[string match $preservation "none"] || [string match $preservation ""] } {
##             puts "\tSkipping lock_design for $hierInst"
##          } else {
##             set errMsg "\nERROR: Unknown value \"$preservation\" specified for lock_design for cell $hierInst."
##             error $errMsg
##          }
##       } else {
##          puts "Cell $hierInst, implemented as OOC, is not a blackbox. OOC implementation results will not be used."
##       }
##    
##       if {$dcpLevel > 1} {
##          set start_time [clock seconds]
##          command "write_checkpoint -force $resultDir/${instName}_link_design_intermediate.dcp" "$resultDir/temp.log"
##          set end_time [clock seconds]
##          log_time write_checkpoint $start_time $end_time 0 "Intermediate link_design checkpoint"
##       }
##    }
## }
## proc generate_pr_binfiles { config } {
##    upvar bitDir bitDir
## 
##    set top           [get_attribute impl $config top]
##    set partitions    [get_attribute impl $config partitions]
##    set icap          [get_attribute impl $config cfgmem.icap]
##    set pcap          [get_attribute impl $config cfgmem.pcap]
##    set offset        [get_attribute impl $config cfgmem.offset]
##    set size          [get_attribute impl $config cfgmem.size]
##    set interface     [get_attribute impl $config cfgmem.interface]
##    if {$icap || $pcap} {
##       foreach partition $partitions {
##          lassign $partition name cell state name type level dcp
##          if {![string match $cell $top]} {
##             set pblock [get_pblock -quiet -of [get_cells $cell]]
##             set bitFile "$bitDir/${config}_${pblock}_partial.bit"
##             if {![file exists $bitFile]} {
##                puts "\tCritical Warning: No bit file found for $name in configuration $config. Skipping BIN file generation. Expected file \n\t$bitFile.\n\tRun write_bitstream first to generate the expected file."
##                return 
##             }
##             if {$icap} {
##                set logFile "$bitDir/write_cfgmem_${config}_${name}_icap.log"
##                set msg "\t#HD: Generating ICAP formatted BIN file for $name of Configuration $config"
##                command "puts \"$msg\""
##                set start_time [clock seconds]
##                set binFile "$bitDir/${config}_${pblock}_partial_icap.bin"
##                #command "write_cfgmem -force -format BIN -interface $interface -loadbit \"$offset $bitFile\" -size $size $binFile" $logFile
##                command "write_cfgmem -force -format BIN -interface $interface -loadbit \"$offset $bitFile\" $binFile" $logFile
##                set end_time [clock seconds]
##                log_time write_cfgmem $start_time $end_time 1 "Generate ICAP format bin file for ${config}(${name})"
##             }
##             if {$pcap} {
##                set logFile "$bitDir/write_cfgmem_${config}_${name}_pcap.log"
##                set msg "\t#HD: Generating PCAP formatted BIN file for $name of Configuration $config"
##                command "puts \"$msg\""
##                set start_time [clock seconds]
##                set binFile "$bitDir/${config}_${pblock}_partial_pcap.bin"
##                #command "write_cfgmem -force -format BIN -interface $interface -disablebitswap -loadbit \"$offset $bitFile\" -size $size $binFile" $logFile 
##                command "write_cfgmem -force -format BIN -interface $interface -disablebitswap -loadbit \"$offset $bitFile\" $binFile" $logFile 
##                set end_time [clock seconds]
##                log_time write_cfgmem $start_time $end_time 1 "Generate PCAP format bin file for ${config}(${name})"
##             }
##          }
##       }
##    } else {
##       puts "\tINFO: Skipping partial BIN file generation for Configuration $config."
##    }
## }
## proc generate_pr_bitstreams { configs } {
##    global dcpDir bitDir implDir
## 
##    #Set a default directory to write bitstreams if not already defined
##    if {![info exists bitDir]} {
##       set bitDir "./Bitstreams"
##    }
## 
##    #command "file delete -force $bitDir"
##    if {![file exists $bitDir]} {
##       command "file mkdir $bitDir"
##    }
## 
##    foreach config $configs {
##       set top           [get_attribute impl $config top]
##       set partitions    [get_attribute impl $config partitions]
##       set bitstream     [get_attribute impl $config bitstream]
##       set bitstream.pre [get_attribute impl $config bitstream.pre]
##       set bitOptions    [get_attribute impl $config bitstream_options]
##       set bitSettings   [get_attribute impl $config bitstream_settings]
##       if {$bitstream} {
##          set start_time [clock seconds]
##          set msg "\t#HD: Running write_bitstream on $config"
##          command "puts \"$msg\""
##          set logFile "$bitDir/write_bitstream_${config}.log"
##          foreach partition $partitions {
##             lassign $partition name cell state name type level dcp
##             if {[string match $cell $top]} {
##                set configFile "$implDir/$config/${top}_route_design.dcp"
##                if {[file exists $configFile]} {
##                   command "open_checkpoint $configFile" "$bitDir/open_checkpoint_$config.log"
##                   #Check for dbg_hub and write out probes
##                   if {[llength [get_cells -quiet -hier -filter REF_NAME==dbg_hub_CV]]} {
##                      command "write_debug_probes -force $bitDir/$config" "$bitDir/write_debug_probes_$config.log"
##                   }
## 
##                   #Run any pre.hook scripts for write_bitstream
##                   foreach script ${bitstream.pre} {
##                      if {[file exists $script]} {
##                         puts "\t#HD: Running pre-bitstream script $script"
##                         command "source $script" "$bitDir/pre_bitstream_script.log"
##                      } else {
##                         set errMsg "\nERROR: Script $script specified for pre-bitstream does not exist"
##                         error $errMsg
##                      }
##                   }
##                   #Set any design level bistream properties
##                   foreach setting $bitSettings {
##                      puts "\tSetting property $setting"
##                      command "set_property $setting \[current_design]"
##                   }
##                   command "write_bitstream -force $bitOptions $bitDir/$config" "$bitDir/$config.log"
##                } else {
##                   puts "\tERROR: The route_design DCP $configFile was not found for $config"
##                   continue
##                }
##             }
##          }
##          set end_time [clock seconds]
##          log_time write_bitstream $start_time $end_time 1 $config
##          generate_pr_binfiles $config 
##          command "close_project" "$bitDir/temp.log"
##       } else {
##          puts "\tSkipping write_bitstream for Configuration $config with attribute \"bitstream\" set to \'$bitstream\'"
##       }
##    }
## }
## proc verify_configs { configs } {
##    global implDir
## 
##    #Compare Initial Configuration to all others
##    set initialConfig [lindex $configs 0]
##    set initialConfigTop [get_attribute impl $initialConfig top]
##    set initialConfigFile $implDir/$initialConfig/${initialConfigTop}_route_design.dcp
## 
##    set numConfigs [llength $configs]
##    set additionalConfigs ""
##    set additionalConfigFiles ""
##    for {set i 1} {$i < $numConfigs} {incr i} {
##       set config [lindex $configs $i]
##       set verify [get_attribute impl $config verify]
##       if {$verify} {
##          lappend additionalConfigs $config
##          set configTop [get_attribute impl $config top]
##          set configFile $implDir/$config/${configTop}_route_design.dcp
##          lappend additionalConfigFiles $configFile
##       } else {
##          puts "\tSkipping pr_verify for Configuration $config with attribute \"verify\" set to \'$verify\'"
##       }
##    }
##    
##    if {[llength $additionalConfigFiles]} {
##       set start_time [clock seconds]
##       set msg "#HD: Running pr_verify between initial config $initialConfig and subsequent configurations $additionalConfigs"
##       command "puts \"$msg\""
##       set logFile "pr_verify_results.log"
##       command "pr_verify -full_check -initial $initialConfigFile -additional \"$additionalConfigFiles\"" $logFile
##       #Parse log file for errors or successful results
##       if {[file exists $logFile]} {
##          set lfh [open $logFile r]
##          set log_data [read $lfh]
##          close $lfh
##          set log_lines [split $log_data "\n" ]
##          foreach line $log_lines {
##             if {[string match "*Vivado 12-3253*" $line] || [string match "*ERROR:*" $line]} {
##                puts "$line"
##             }
##          }
##       }
##       set end_time [clock seconds]
##       log_time pr_verify $start_time $end_time 1 "[llength $configs] Configurations"
##    }
## }
## proc add_xdc { xdc { synth 0} } {
##    puts "\tAdding XDC files"
##    #Flatten list if nested lists exist
##    set files [join [join $xdc]]
##    foreach file $files {
##       if {[file exists $file]} {
##          command "add_files $file"
##          set file_split [split $file "/"]
##          set fileName [lindex $file_split end]
##          if { $synth ==2 || [string match "*synth*" $fileName] } { 
##             if {[string match "*ooc*" $fileName]} {
##                command "set_property USED_IN {synthesis out_of_context} \[get_files $file\]"
##             } else {
##                command "set_property USED_IN {synthesis} \[get_files $file\]"
##             }
##          } elseif { $synth==1 } {
##             if {[string match "*ooc*" $fileName]} {
##                command "set_property USED_IN {synthesis implementation out_of_context} \[get_files $file\]"
##             } else {
##                command "set_property USED_IN {synthesis implementation} \[get_files $file\]"
##             }
##          } else {
##             if {[string match "*ooc*" $fileName]} {
##                command "set_property USED_IN {implementation out_of_context} \[get_files $file\]"
##             } else {
##                command "set_property USED_IN {implementation} \[get_files $file\]"
##             }
##          }
## 
##          if {[string match "*late*" $fileName]} {
##             command "set_property PROCESSING_ORDER late \[get_files $file\]"
##          } elseif {[string match "*early*" $fileName]} {
##             command "set_property PROCESSING_ORDER early \[get_files $file\]"
##          }
##       } else {
##          set errMsg "\nERROR: Could not find specified XDC: $file" 
##          error $errMsg 
##       }
##    }
## }
## proc readXDC { xdc {cell ""} } {
##    upvar resultDir resultDir
## 
##    puts "\tReading XDC files"
##    #Flatten list if nested lists exist
##    set files [join [join $xdc]]
##    foreach file $files {
##       if {[file exists $file]} {
##          if {![llength $cell]} {
##             command "read_xdc $file" "$resultDir/read_xdc.log"
##          } else {
##             command "read_xdc -cell $cell $file" "$resultDir/read_xdc_cell.log"
##          }
##       } else {
##          set errMsg "\nERROR: Could not find specified XDC: $file" 
##          error $errMsg 
##       }
##    }
## }
## proc add_ip { ips } {
##    upvar resultDir resultDir
## 
##    foreach ip $ips {
##       if {[string length ip] > 0} { 
##          if {[file exists $ip]} {
##             set ip_split [split $ip "/"] 
##             set xci [lindex $ip_split end]
##             set ipPathList [lrange $ip_split 0 end-1]
##             set ipPath [join $ipPathList "/"]
##             set ipName [lindex [split $xci "."] 0]
##             set ipType [lindex [split $xci "."] end]
##             puts "\t#HD: Adding \'$ipType\' file $xci"
##             command "add_files $ipPath/$xci" "$resultDir/${ipName}_add.log"
##             if {[string match $ipType "bd"]} {
##                return
##             }
##             if {[get_property GENERATE_SYNTH_CHECKPOINT [get_files $ipPath/$xci]]} {
##                if {![file exists $ipPath/${ipName}.dcp]} {
##                   puts "\tSynthesizing IP $ipName"
##                   command "synth_ip \[get_files $ipPath/$xci]" "$resultDir/${ipName}_synth.log"
##                }
##             } else {
##                puts "\tGenerating output for IP $ipName"
##                command "generate_target all \[get_ips $ipName]" "$resultDir/${ipName}_generate.log"
##             }
##          } else {
##             set errMsg "\nERROR: Could not find specified IP file: $ip" 
##             error $errMsg
##          }
##       }
##    }
## }
## proc add_cores { cores } {
##    puts "\tAdding core files"
##    #Flatten list if nested lists exist
##    set files [join [join $cores]]
##    foreach file $files {
##       if {[string length $file] > 0} { 
##          if {![file exists $file]} {
##             #Comment this out to prevent adding files 1 at a time. Add all at once instead.
##             #command "add_files $file"
##             set errMsg "\nERROR: Could not find specified IP netlist: $file" 
##             error $errMsg
##          }
##       }
##    }
##    #Check to make sure file list is not empty
##    if {[string length $files] > 0} { 
##       command "add_files $files"
##    }
## }
## proc check_drc { module {ruleDeck all} {quiet 0} } {
##    upvar reportDir reportDir
## 
##    if {[info exists reportDir]==0} {
##       set reportDir "."
##    }
##    puts "\tRunning report_drc with ruledeck $ruleDeck.\n\tResults saved to $reportDir/${module}_drc_$ruleDeck.rpt" 
##    command "report_drc -ruledeck $ruleDeck -name $module -file $reportDir/${module}_drc_$ruleDeck.rpt" "$reportDir/temp.log"
##    set Advisories   [get_drc_violations -quiet -name $module -filter {SEVERITY=~"Advisory"}]
##    set Warnings     [get_drc_violations -quiet -name $module -filter {SEVERITY=~"Warning"}]
##    set CritWarnings [get_drc_violations -quiet -name $module -filter {SEVERITY=~"Critical Warning"}]
##    set Errors       [get_drc_violations -quiet -name $module -filter {SEVERITY=~"Error"}]
##    puts "\tAdvisories: [llength $Advisories]; Warnings: [llength $Warnings]; Critical Warnings: [llength $CritWarnings]; Errors: [llength $Errors];"
## 
##    if {[llength $Errors]} {
##       if {!$quiet} {
##          set errMsg "\nERROR: DRC found [llength $Errors] errors ($Errors)."
##       } else {
##          puts "\tCritical Warning: DRC found [llength $Errors] errors ($Errors)."
##       }
##       foreach error $Errors {
##          puts "\n\t${error}: [get_property DESCRIPTION [get_drc_violations -name $module $error]]"
##       }
##       #Stop the script for Errors, unless user specifies quiet as true
##       if {!$quiet} {
##          error $errMsg
##       }
##    }
## 
##    if {[llength $CritWarnings]} {
##       if {!$quiet} {
##          set errMsg "\nERROR: DRC found [llength $CritWarnings] Critical Warnings ($CritWarnings)."
##       } else {
##          puts "\tCritical Warning: DRC found [llength $CritWarnings] Critical Warnings ($CritWarnings)."
##       }
##       foreach cw $CritWarnings {
##          puts "\n\t${cw}: [get_property DESCRIPTION [get_drc_violations -name $module $cw]]"
##       }
##       #Stop the script for Critcal Warnings, unless user specifies quiet as true
##       if {!$quiet} {
##          error $errMsg
##       }
##    }
## }
## proc printRuleDecks { {decks ""} } {
##    if {[llength $decks]} {
##       set rules [get_drc_checks -of [get_drc_ruledecks $decks]]
##       foreach rule $rules {
##          set name [get_property NAME [get_drc_checks $rule]]
##          set description [get_property DESCRIPTION [get_drc_checks $rule]]
##          set severity [get_property SEVERITY [get_drc_checks $rule]]
##          puts "\t${name}(${severity}): ${description}"
##       }
##    } else {
##       puts "Rule Decks:\n\t[join [get_drc_ruledecks] "\n\t"]"
##    }
## }
## proc printRules { rules } {
##    foreach rule $rules {
##       set name [get_property NAME [get_drc_checks $rule]]
##       set description [get_property DESCRIPTION [get_drc_checks $rule]]
##       set severity [get_property SEVERITY [get_drc_checks $rule]]
##       puts "\t${name}(${severity}): $description"
##    }
## }
## proc get_bad_pins { cell } {
##    set noPP_pins [get_pins -of [get_cells $cell] -filter "HD.ASSIGNED_PPLOCS!~*INT* && HD.ASSIGNED_PPLOCS!~*INT*"]
##    set io_pins [get_pins -of [get_nets -of [get_cells -hier -filter LIB_CELL=~*BUF*]] -filter PARENT_CELL==$cell]
##    set count 0
##    set clock_pins ""
##    set bad_pins ""
##    foreach pin $noPP_pins {
##       set clock [get_clocks -quiet -of [get_pins $pin]]
##       if { [lsearch -exact $io_pins $pin]!="-1" } {
##   #       puts "Found match: $pin"
##       } else {
##          if { $clock!=""} {
##   #          puts "Found clock: $pin"
##             lappend clock_pins $pin
##          } else {
##   #          puts "No match found: $pin"
##             lappend bad_pins $pin
##          }
##       }
##    }
##    puts "[join $bad_pins "\n"]"
##    puts "\nTotal Number of pins without PP: [llength $noPP_pins]"
##    puts "Total Number of pins connected to buffers: [llength $io_pins]"
##    puts "Total Number of clock pins: [llength $clock_pins]"
##    puts "Total Number of \"bad\" pins: [llength $bad_pins]"
## }
## proc get_bad_ports { } {
##    set noPP_ports [get_ports -filter "HD.PARTPIN_LOCS!~*INT* && HD.ASSIGNED_PPLOCS!~*INT*"]
##    set io_ports [get_ports -of [get_nets -of [get_cells -hier -filter LIB_CELL=~*BUF*]]]
##    set count 0
##    set clock_ports ""
##    set bad_ports ""
##    foreach port $noPP_ports {
##       set clock [get_clocks -quiet -of [get_ports $port]]
##       if { [lsearch -exact $io_ports $port]!="-1" } {
##    #      puts "Found match: $port"
##       } else {
##          if { $clock!=""} {
##    #         puts "Found clock: $port"
##              lappend clock_ports $port
##          } else {
##    #         puts "No match found: $port"
##             lappend bad_ports $port
##          }
##       }
##    }
##    puts "[join $bad_ports "\n"]"
##    puts "\nTotal Number of ports without PP: [llength $noPP_ports]"
##    puts "Total Number of ports connected to buffers: [llength $io_ports]"
##    puts "Total Number of clock ports: [llength $clock_ports]"
##    puts "Total Number of \"bad\" ports: [llength $bad_ports]"
## }
## proc insert_proxy_flop { cell } {
## 
##    if {[get_property IS_BLACKBOX [get_cells $cell]] == 0} {
##       puts "ERROR: Specified cell $cell is not a blackbox.\nThe Tcl proc insert_proxy_flop can only be run on a cell that is a black box. Specify a black box cell, or run \'update_design -cell $cell -black_box\' prior to running this command."
##       return 1
##    }
## 
##    set all_in_pins [lsort [get_pins -of [get_cells $cell] -filter DIRECTION==IN]]
##    set all_out_pins [lsort [get_pins -of [get_cells $cell] -filter DIRECTION==OUT]]
##    #### Get a list of all clock pins (driver is a BUFG, BUFR, BUFH, etc)
##    foreach inpin $all_in_pins {
##       #Get the leaf level driver of the input pin
##       set driver [get_cells -quiet -of [get_pins -quiet -leaf -of [get_nets -of [get_pins $inpin]] -filter DIRECTION==OUT]]
##       #Check for direct connects to ports
##       set port [get_ports -quiet -of [get_nets -of [get_pins $inpin]]]
##       if {![llength $driver] || [llength $port] || [string match "GND" $driver] || [string match "VCC" $driver] } {
##          puts "Info: No synchronous driver found for input pin $inpin. Skipping insertion."
##          continue
##       }
##       if {[string match -nocase "BUF*" [get_property -quiet LIB_CELL [get_cells -quiet $driver]]]} {
##          lappend clocks $inpin 
##       } else {
##          lappend in_pins $inpin
##       }
##    }
##    puts "Found [llength $clocks] clock pins."
##    puts "Found [llength $in_pins] active input pins."
##    foreach clock $clocks {
##       puts "Creating clock net \"$clock\""
##       create_net $clock
##       connect_net -net $clock -objects "$clock"
##    }
## 
##    ####Process input pins, minus those driven by BUFG
##    puts "Inserting Proxy Flops for input pins"
##    foreach inpin $in_pins {
##       create_cell -reference FDCE ${inpin}_PROXY
##       create_net $inpin
##       connect_net -net $inpin -objects "$inpin ${inpin}_PROXY/D"
##       set endpoints [get_cells -quiet -of [all_fanin -quiet -startpoints_only -flat [get_pins $inpin]]]
##       set foundClock 0
##       foreach endpoint $endpoints {
##          #If the element is sequential 
##          if {[get_property -quiet IS_SEQUENTIAL [get_cells -quiet $endpoint]]} {
##             #puts "Found sequential driver \"$endpoint\" for pin $inpin"
##             set driver_clock [get_nets -quiet [get_nets -quiet -segments -of [get_pins -of [get_cells $endpoint] -filter IS_CLOCK]] -filter NAME=~$cell/*]
##             if {[llength $driver_clock] > 0 && [lsearch $clocks [lindex $driver_clock 0]] >= 0} {
##                #puts "\tFound clock connections: $driver_clock"
##                connect_net -net [lindex $driver_clock 0] -objects "${inpin}_PROXY/C"
##                set foundClock 1
##                break
##             }
##          } 
##       }
##       if {$foundClock == 0} {
##          #Connect the inserted flop to the first clock in the list if the above fails 
##          puts "Info: No common clock connection found for input pin $inpin. Removing inserted flop."
##          remove_net $inpin 
##          remove_cell ${inpin}_PROXY
##       }
##    }
## 
##    ####Process output pins
##    puts "\nFound [llength $all_out_pins] output pins."
##    puts "Inserting Proxy Flops for output pins"
##    #Create a local GND cell to tie-off output flops.
##    create_cell $cell/GND -reference GND
##    create_net $cell/<const0>
##    connect_net -net $cell/<const0> -objects $cell/GND/G
##    foreach outpin $all_out_pins {
##       create_cell -reference FDCE ${outpin}_PROXY
##       create_net $outpin
##       connect_net -net $outpin -objects "$outpin ${outpin}_PROXY/Q"
##       #Tie off input to inserted output flop
##       connect_net -net $cell/<const0> -objects "${outpin}_PROXY/D"
##       set endpoints [get_cells -quiet -of [all_fanout -quiet -endpoints_only -flat [get_pins $outpin]]]
##       #Check for direct connects to ports
##       append endpoints [get_ports -quiet -of [get_nets -quiet -of [get_pins $outpin]]]
##       if {![llength $endpoints]} {
##          puts "Info: No loads found for output pin $outpin"
##       }
##       set foundClock 0
##       foreach endpoint $endpoints {
##          set load [get_property -quiet IS_SEQUENTIAL [get_cells -quiet $endpoint]]
##          if {[llength $load]} {
##             #puts "Found sequential load \"$endpoint\" for pin $outpin"
##             set load_clock [get_nets -quiet [get_nets -quiet -segments -of [get_pins -of [get_cells $endpoint] -filter IS_CLOCK]] -filter NAME=~$cell/*]
##             if {[llength $load_clock] > 0 && [lsearch $clocks [lindex $load_clock 0]] >= 0} {
##                #puts "\tFound clock connections: $load_clock"
##                connect_net -net [lindex $load_clock 0] -objects "${outpin}_PROXY/C"
##                set foundClock 1
##                break
##             }
##          }
##       }
##       if {$foundClock == 0} {
##          #Connect the inserted flop to the first clock in the list if the above fails 
##          puts "Info: No common clock connection found for output pin $outpin. Removing inserted flop."
##          remove_net $outpin
##          remove_cell ${outpin}_PROXY
##       }
##    }
##    set_property HD.PARTITION 1 [get_cells $cell]
## }
## proc verbose {} {
##    set_param place.hardVerbose   469538
##    set_param place.oldMsgVerbose 1
##    set_param place.GPPlot        1
##    set_param route.flowDbg       1
##    set_param route.timingDbg     1
##    set_param route.promoteErrors true
## }
## proc fix_timing {} {
##    set clk_intr [split [report_clock_interaction -return_string] \n]
##    foreach line $clk_intr {
##       if { [regexp {^(\S+)\s+(\S+)\s+\S+.*Timed \(unsafe\).*} $line full src dst]} {
##          set_false_path -from [get_clocks $src] -to [get_clocks $dst]
##       }
##    }
## }
# source $tclDir/pr_utils.tcl
## proc pr_unplace {} {
##    route_design -unroute
##    place_design -unplace
##    set cells [get_cells -quiet -hier -filter HD.RECONFIGURABLE]
##    foreach cell $cells {
##       reset_property HD.PARTPIN_LOCS [get_pins $cell/*]
##       reset_property HD.PARTPIN_RANGE [get_pins $cell/*]
##    }
## }
## proc toggle_pr { cells } {
##    if {[catch current_instance]} {
##       puts "INFO: No open design."
##       return
##    }
##    foreach cell $cells {
##       if {[get_property HD.RECONFIGURABLE [get_cells $cell]] != "1"} {
##          set_property HD.RECONFIGURABLE 1 [get_cells $cell]
##       } else {
##          set_property HD.RECONFIGURABLE 0 [get_cells $cell]
##       }
##    } 
## }
## proc get_rps {} {
##    if {[catch current_instance]} {
##       puts "INFO: No open design."
##       return
##    }
##    set rps [get_cells -quiet -hier -filter HD.RECONFIGURABLE]
##    if {![llength $rps]} {
##       puts "Info: No cells found with HD.RECONFIGURABLE==1"
##       return
##    }
##    return $rps
## }
## proc get_bb {} {
##    if {[catch current_instance]} {
##       puts "INFO: No open design."
##       return
##    }
##    set bb [get_cells -quiet -hier -filter IS_BLACKBOX]
##    if {![llength $bb]} {
##       puts "Info: No blackbox cells found"
##       return
##    }
##    return $bb
## }
## proc bb { cells } {
##    if {[catch current_instance]} {
##       puts "INFO: No open design."
##       return
##    }
##    foreach cell $cells {
##       update_design -black_box -cell $cell
##    }
## }
## proc gb { cells } {
##    if {[catch current_instance]} {
##       puts "INFO: No open design."
##       return
##    }
##    foreach cell $cells {
##       update_design -buffer_ports -cell $cell
##    }
## }
## proc delete_PartPins { RPs } {
##    foreach rp $RPs {
##       reset_property HD.PARTPIN_RANGE [get_pins $rp/*]
##       reset_property HD.PARTPIN_LOCS  [get_pins $rp/*]
##    }
## }
## proc get_pp_range { cell } {
##    set pp_range_sites ""
##    set pp_ranges ""
##    set pins [get_pins -filter HD.PARTPIN_RANGE!="" -of [get_cells $cell]]
##    foreach pin $pins {
##       set ranges [get_property HD.PARTPIN_RANGE [get_pins $pin]]
##       if {[llength $ranges]} {
##          foreach range $ranges {
##             if {[lsearch -exact $pp_ranges $range]==-1} {
##                puts "Found unique range $range"
##                lappend pp_ranges $range
##                lappend pp_range_sites [get_sites -range $range]
##             }
##          }
##       }
##    }
##    set sites [concat {*}$pp_range_sites]
##    highlight_objects -color yellow [get_sites [lsort $sites]]
## }
## proc get_rp_clocks { cell {file ""}} {
##    set table " -row {\"Clock Pin\" \"Clock Net\" \"Clock Driver\" \"Driver Type\" \"RM Loads\" \"Static Loads\"}"
##    set count 0
##    set clockNets ""
##    set staticLods ""
##    set pins [get_pins $cell/* -filter DIRECTION==IN]
##    foreach pin $pins {
##       set clock_driver [get_cells -quiet -of [get_pins -quiet -leaf -of [get_nets -quiet -of $pin] -filter DIRECTION==OUT] -filter REF_NAME=~BUF*]
##       if {[llength $clock_driver]} {
##          incr count
##          set clock_net [get_nets -of [get_pins $pin]]
##          set driver_type [get_property REF_NAME [get_cells $clock_driver]]
##          set rm_loads [llength [get_pins -quiet -leaf -of $clock_net -filter NAME=~$cell/*]]
##          set static_pins [get_pins -quiet -leaf -of $clock_net -filter "NAME!~$cell/* && DIRECTION==IN"]
##          set static_loads [llength $static_pins]
##          append table " -row {$pin $clock_net $clock_driver $driver_type $rm_loads $static_loads}"
##          lappend clockNets $clock_net
##          lappend staticLoads [get_cells -quiet -of $static_pins -filter "REF_NAME!~BUF* && REF_NAME!~MMCM* && REF_NAME!~PLL*"]
##       }
##    }
##    set title "-title {#HD: Clock information for RP $cell ($count clocks total)}"
##    set table ${title}${table}
##    if {[llength $file]} {
##       print_table $table -file $file
##    } else {
##       print_table $table
##    }
##    return $clockNets
## #   return $staticLoads
## }
## proc get_limit_clocks {{limit 4}} {
##    set clocks [get_clocks -quiet]
##    puts "Found [llength $clocks] clocks in the design"
##    set clockCount 0
##    set title "-title {Total Clocks:[llength $clocks] in design. Reporting on clocks with $limit or less connections}"
##    set table " -row {\"\" \"Clock\" \"Total Loads\" \"Load Types\" \"Driver Type\"}"
##    foreach clock $clocks {
##       set loads  [get_pins -quiet -leaf -filter DIRECTION==IN -of [get_nets -of $clock]]
##       set driver [get_pins -quiet -leaf -filter DIRECTION==OUT -of [get_nets -of $clock]]
##       if {[llength $loads]<=$limit} {
##          incr clockCount
##          if {[llength $driver]} {
##             append table " -row {$clockCount $clock [llength $loads] [list [get_property REF_NAME $loads]] [get_property REF_NAME $driver]}"
##          } elseif {[llength [get_ports -quiet -of [get_nets -of $clock]]]} {
##             set driver [get_ports -of [get_nets -of $clock]]
##             append table " -row {$clockCount $clock [llength $loads] [list [get_property REF_NAME $loads]] Port\($driver\)}"
##          } else {
##             append table " -row {$clockCount $clock [llength $loads] [list [get_property REF_NAME $loads]] Unknown}"
##          }
##       }
##    }
##    print_table $table
## }
## proc get_overlapping_nodes {{limit 0}} {
##    set nets [get_nets -hier -filter ROUTE_STATUS==CONFLICTS]
##    puts "Found [llength $nets] nets with Conflicts."
##    set nodes [get_nodes -of $nets]
##    puts "Parsing [llength $nodes] nodes for potential overlaps."
##    set nodeOverlaps {}
##    set count 0
##    set lineCount 0
## 
##    puts -nonewline "0 "
##    foreach node $nodes {
##       #If a limit is specified, stop after #limit overlapping nodes are found
##       if {$limit > 0} {
##          if {[llength $nodeOverlaps] == $limit} {
##             break
##          }
##       }
##       set nodeNets [get_nets -quiet -of $node]
##       if {[llength $nodeNets] > 1} {
##          lappend nodeOverlaps $node
##       }
##       incr count
##       #Add a "." for every 100 nodes checked
##       if {[expr fmod($count,100)]==0.0} {
##          puts -nonewline "."
##       }
## 
##       #Add a new line of "."s for every 1000 nodes
##       if {$count == 1000} {
##          set count 0
##          incr lineCount
##          puts ""
##          puts -nonewline "${lineCount}k"
##       }
##    }
##    puts "\nFound [llength $nodeOverlaps] overlapping nodes."
##    if {[llength $nodeOverlaps]} {
##       select_objects $nodeOverlaps
##       highlight_objects -color red [get_selected_objects]
##    }
## }
## proc export_partpins { args } {
##    set FH "stdout"
##    set pins [get_pins -hier * -filter HD.ASSIGNED_PPLOCS!=""]
##    array set options {-pblocks $pblocks -file ""}
## 
##    #Override defaults with command options
##    set argLength [llength $args]
##    set index 0
##    while {$index < $argLength} {
##       set arg [lindex $args $index]
##       set value [lindex $args [expr $index+1]]
##       switch -exact -- $arg {
##          {-cells}  {set cells [get_cells $value]}
##          {-file}     {set FH [open $value w]}
##          {-help}     {set     helpMsg "Description:"
##                       lappend helpMsg "Exports Partition Pins from in memory design to STDOUT or specified file.\n"
##                       lappend helpMsg "Syntax:"
##                       lappend helpMsg "export_partpins\t\[-cells <arg>] \[-file <arg>]\n"
##                       lappend helpMsg "Usage:"
##                       lappend helpMsg "  Name                        Description"
##                       lappend helpMsg "  ---------------------------------------"
##                       lappend helpMsg "  \[-cells]                  Optional. Specifies the list of Cells to export."
##                       lappend helpMsg "                              If no Cells are specified, all PartPins will be exported." 
##                       lappend helpMsg "  \[-file]                   Optional. Specifies the output file name."
##                       lappend helpMsg "                              If not specified the output will be written to STDOUT"
##                       lappend helpMsg "  \[-help]                   Displays this message\n\n"
##                       foreach line $helpMsg {
##                          puts $line
##                       }
##                       return
##                      }
##          default     {set errMsg "ERROR: Specified argument $arg is not supported.\n"
##                       append errMsg "Supported arguments are -help, -pblocks, and -file.\n"
##                       append errMsg "Use the -help option for more details"
##                       error $errMsg 
##                      }
##       }
##       set index [expr $index + 2]
##    }
##    
##    if {![info exists cells]} {
##       set errMsg "Error: No -cells option specificed. A cell must be specified with this option."
##       error $errMsg
##    }
## 
##    #if -cell is used, clear out pin list and create a list based of of specified cells
##    if {[llength $cells]} {
##       foreach cell $cells {
##          foreach pin [lsort -dict [get_pins -of [get_cells $cell] -filter HD.ASSIGNED_PPLOCS!=""]] {
##             puts $FH "set_property HD.PARTPIN_LOCS [lindex [get_property HD.ASSIGNED_PPLOCS $pin] 0] \[get_pins \{$pin\}\]"
##             flush $FH
##          }
##       }
##    }
##    close $FH
## }
## proc export_pblocks { args } {
## 
##    set FH "stdout"
##    set pblocks [get_pblocks]
##    array set options {-pblocks $pblocks -file ""}
## 
##    #Override defaults with command options
##    set argLength [llength $args]
##    set index 0
##    while {$index < $argLength} {
##       set arg [lindex $args $index]
##       set value [lindex $args [expr $index+1]]
##       switch -exact -- $arg {
##          {-pblocks}  {set pblocks [get_pblocks $value]}
##          {-file}     {set FH [open $value w]}
##          {-help}     {set     helpMsg "Description:"
##                       lappend helpMsg "Exports Pblocks from in memory design to STDOUT or specified file.\n"
##                       lappend helpMsg "Syntax:"
##                       lappend helpMsg "export_pblocks\t\[-pblocks <arg>] \[-file <arg>]\n"
##                       lappend helpMsg "Usage:"
##                       lappend helpMsg "  Name                        Description"
##                       lappend helpMsg "  ---------------------------------------"
##                       lappend helpMsg "  \[-pblocks]                  Optional. Specifies the list of Pblocks to export."
##                       lappend helpMsg "                              If no Pblocks are specified, all Pblocks will be exported." 
##                       lappend helpMsg "  \[-file]                    Optional. Specifies the output file name."
##                       lappend helpMsg "                               If not specified the output will be written to STDOUT"
##                       lappend helpMsg "  \[-help]                    Displays this message\n\n"
##                       foreach line $helpMsg {
##                          puts $line
##                       }
##                       return
##                      }
##          default     {set errMsg "ERROR: Specified argument $arg is not supported.\n"
##                       append errMsg "Supported arguments are -help, -pblocks, and -file.\n"
##                       append errMsg "Use the -help option for more details"
##                       error $errMsg 
##                      }
##       }
##       set index [expr $index + 2]
##    }
## 
##    foreach pblock $pblocks {
##       puts $FH "\n\n####Pblock $pblock####"
##       puts $FH "create_pblock $pblock"
##       set cells [get_cells -quiet -of [get_pblocks $pblock]]
##       if {[llength $cells]} {
##          puts $FH "add_cells_to_pblock \[get_pblocks $pblock\] \[get_cells \[list $cells\]\]"
##       }
##       set grids  [get_property GRIDTYPES [get_pblock $pblock]]
##       set ranges [get_property GRID_RANGES [get_pblocks $pblock]]
##       set matchedRanges ""
##       foreach grid $grids {
##          set grid_ranges ""
##          foreach range $ranges {
##             regexp {(\w+)_(X\d+Y\d+)} $range temp type value
##             if {[string match $grid $type]} {
##                lappend grid_ranges $range
##             }
##          }
##          if {[llength $grid_ranges]} {
##             puts $FH "resize_pblock \[get_pblocks $pblock\] -add \{$grid_ranges\}"
##             lappend matchedRanges $grid_ranges
##          } else {
##             puts "Critical Warning: Found GRIDTYPE $grid, but no ranges of the matching type in Pblock range for Pblock $pblock:\n$ranges"
##          }
##       }
## 
##       #Detect Ranges in Pblock with no matching GRIDTYPES (like BUFG or IO in non-PR Pblock)
##       foreach range $ranges {
##          if {[lsearch [join $matchedRanges] $range]==-1} {
##             puts $FH "resize_pblock \[get_pblocks $pblock\] -add \{$range\}"
##          }
##       }
## 
##       ##Check for addtitional Pblock properties
##       if {[get_property PARTPIN_SPREADING [get_pblocks $pblock]] != 5} {
##          puts $FH "set_property PARTPIN_SPREADING [get_property PARTPIN_SPREADING [get_pblocks $pblock]] \[get_pblocks $pblock\]"
##       }
##       if {[llength [get_property SNAPPING_MODE [get_pblocks $pblock]]]} {
##          puts $FH "set_property SNAPPING_MODE [get_property SNAPPING_MODE [get_pblocks $pblock]] \[get_pblocks $pblock\]"
##       }
##       if {[get_property CONTAIN_ROUTING [get_pblocks $pblock]]} {
##          puts $FH "set_property CONTAIN_ROUTING 1 \[get_pblocks $pblock\]"
##       }
##       if {[get_property EXCLUDE_PLACEMENT [get_pblocks $pblock]]} {
##          puts $FH "set_property EXCLUDE_PLACEMENT 1 \[get_pblocks $pblock\]"
##       }
##       if {[get_property RESET_AFTER_RECONFIG [get_pblocks $pblock]]} {
##          puts $FH "set_property RESET_AFTER_RECONFIG 1 \[get_pblocks $pblock\]"
##       }
##       if {![string match "ROOT" [get_property PARENT [get_pblocks $pblock]]]} {
##          puts $FH "set_property PARENT [get_property PARENT [get_pblocks $pblock]] \[get_pblocks $pblock\]"
##       }
##       flush $FH
##    }
##    if {![string match $FH "stdout"]} {
##       close $FH
##    }
## }
## proc highlight_internal_nets { cell {color red} } {
## 
##    if {[get_property IS_BLACKBOX [get_cells $cell]]} {
##       puts "Info: Cell $cell is a blackbox, and will not be processed."
##       return
##    }
##    #Get a list of all nets that match the cell name, but filter out clocks and Global_Logic
##    set nets [get_nets -hier -filter "NAME=~$cell/* && TYPE!=GLOBAL_CLOCK && TYPE!=GND && TYPE!=VCC && TYPE!= POWER && TYPE!=GROUND"]
##    puts "All nets from $cell: [llength $nets]"
##    set internal_nets ""
##    foreach net $nets {
##       #get a list of all leaf level pins that the net connects to
##       set pins [get_pins -quiet -leaf -of [get_nets $net]]
##       set external 0
##       #Look at each pin to see if connects to a pin outside of the specified cell
##       #If it does, ignore this net and move on (break)
##       foreach pin $pins {
##          if {![string match "$cell/*" $pin]} {
##             set external 1
##             break
##          }
##       }
##       if {!$external} {
##          lappend internal_nets $net
##       }
##    }
##    llength $internal_nets
##    puts "Internal nets of $cell: [llength $internal_nets]"
##    highlight_objects -color $color [get_nets $internal_nets]
## }
## proc fix_interface_nets { cell {xdc ""} } {
##    #Define default file name if one is not specified
##    if {![llength $xdc]} {
##       set xdc "[lindex [split $cell /] end].xdc"
##    }
##    #Check to see if any pins have PartPins
##    set pins [get_pins $cell/* -filter HD.ASSIGNED_PPLOCS!=""]
##    if {![llength $pins]} {
##       return
##    }
##    puts "Creating output file \"$xdc\""
##    set FH [open $xdc w]
##    foreach pin $pins {
##       if {[llength [get_property HD.ASSIGNED_PPLOCS $pin]]} {
##          set net [get_nets -of $pin]
##          set_property IS_ROUTE_FIXED 1 $net
##          puts $FH "set_property FIXED_ROUTE [get_property FIXED_ROUTE $net] \[get_nets $net\]"
##          flush $FH
##          set_property IS_ROUTE_FIXED 0 $net
##       }
##    }
##    close $FH
## }
## proc create_training_kernel { dcps } {
##    array set module {}
##    #Check if all specified DCPs exists
##    foreach dcp $dcps {
##       if {![file exists $dcp]} {
##          set errMsg "Error: Specified DCP does not exist.\n$dcp" 
##          error $errMsg
##       }
##    }
##    
##    set LFH [open "training_kernel.log" w]
##    #Open each DCP and get the worst case load/drivers in the RM.
##    foreach dcp $dcps {
##       puts "Opening DCP $dcp"
##       open_checkpoint $dcp > temp.log
##       set part [get_property PART [current_design]]
##       #Get the module name make sure it matches between all versions of specified DCPs.
##       set top [get_property TOP [current_design]]
##       if {[info exists name]} {
##          if {![string match $name $top]} {
##             set errMsg "Error: Value of property top ($top) does match previous value $name."
##             error $errMsg
##           }
##       } else {
##          set name $top
##       }
## 
##       foreach port_object [lsort -dict [get_ports ]] {
##          set port [get_property NAME $port_object]
##          #puts $LFH "Examining Port $port"
##          set info [get_loads $port]
##          lassign $info levels loads clock direction
##          set level [lindex $info 0]
##          if {![info exists module($port)] || $level >= [lindex $module($port) 0]} { 
##             #puts $LFH "Setting $info for $port"
##             set module($port) $info
##          } else {
##              puts "\tPrevious value [lindex $module($port) 0] was greater that new value $level for $port"
##          }
##       }
##       close_project
##       puts "Done with DCP $dcp"
##    }
##    
## 
##    puts "Creating kernel for $name"
##    #Create an empty design (OOC) to start creating the training kernel
##    link_design -part $part -mode out_of_context
##    rename_ref -ref netlist_EMPTY -to $name
## 
## #   set table "-title \"$name - $dcp\""
## #   append table " -row {Ports Direction Levels Loads Clock}"
##    #Define all clock ports and create clock nets
##    foreach port [lsort -dict [array names module]] {
##       lassign $module($port) levels loads clock direction
## #      append table " -row {$port $direction $levels $loads $clock}"
##       if {[string match $clock "is_clock"]} {
##          create_clock_port $port
##       }
##    }
## #   append $table " -handle $LFH"
## #   print_table $table 
## 
##    #Create a GND cell/net to drive output flops
##    create_cell GND -reference GND
##    create_net <const0>
##    connect_net -net <const0> -objects [get_pins GND/G]
## 
##    #Create data ports with specified levels of logic
##    foreach port [lsort -dict [array names module]] {
##       lassign $module($port) levels loads clock direction
##       if {![string match $clock "is_clock"]} {
##          if {[string match $direction "IN"]} {
##             puts "Creating Input Port $port:"
##             create_input_port $port $module($port)
##          } elseif {[string match $direction "OUT"]} {
##             puts "Creating Output Port $port:"
##             create_output_port $port $module($port)
##          } else {
##             set errMsg "ERROR: Invalid direction $direction specfied for port $port"
##             error $errMsg
##          }
##       }
##    }
## 
##    close $LFH
##    #Apply DONT_TOUCH constraints to prevent optimization
##    puts "Setting DONT_TOUCH properties"
##    set_property DONT_TOUCH 1 [get_cells]
##    set_property DONT_TOUCH 1 [get_nets]
## 
##    #Export newly created training module to be used as initial RM
##    write_checkpoint -force ${name}_training_synth.dcp
##    close_project
## }
## proc create_clock_port { port } {
##    upvar LFH LFH
##    set direction "IN"
##    puts $LFH "Creating clock port $port"
##    regexp {(.*)\[(\d*)\]} $port port portName portIndex
##    if {[info exists portIndex]} {
##       create_port -direction $direction $portName -from $portIndex -to $portIndex
##       set portRef ${portName}_$portIndex
##    } else {
##       create_port -direction $direction $port
##       set portRef $port
##    } 
##    create_net $portRef
##    connect_net -net $portRef -objects [get_ports $port]
## }
## proc create_output_port {port info} {
##    upvar LFH LFH
##    lassign $info levels loads clock direction
##    puts $LFH "Creating logic for output port: $port\tClock port: $clock\tLevels of logic: $levels"
##    regexp {(.*)\[(\d*)\]} $port port portName portIndex
##    if {[info exists portIndex]} {
##       create_port -direction $direction $portName -from $portIndex -to $portIndex
##       set portRef ${portName}_$portIndex
##    } else {
##       create_port -direction $direction $port
##       set portRef $port
##    } 
##    #puts "\tCreating Nets and Cells for $port using unique reference $portRef"
##    if {[string match $clock "none"]} {
##       puts "Critical Warnings: Created output port $port with no synchronous Driver. Consider removing this port from the RP interface."
##       return 
##    } elseif {$levels==0} {
##       regexp {(.*)\[(\d*)\]} $clock clock clockName clockIndex
##       if {[info exists clockIndex]} {
##          set clockRef ${clockName}_$clockIndex
##       } else {
##          set clockRef $clock
##       }
##       create_net ${portRef}
##       create_cell -reference FDRE ${portRef}_FDRE
##       connect_net -net $portRef -objects [list [get_ports $port] [get_pins ${portRef}_FDRE/Q]]
##       connect_net -net $clockRef -objects [get_pins ${portRef}_FDRE/C]
##       connect_net -net <const0> -objects [get_pins ${portRef}_FDRE/D]
##    } else {
##       for {set i 0} {$i <= $levels} {incr i} {
##          if {$i==0} {
##             create_net ${portRef}_$i
##             create_cell -reference LUT1 ${portRef}_LUT1_$i
##             set_property INIT 2'h2 [get_cells ${portRef}_LUT1_$i]
##             connect_net -net ${portRef}_$i -objects [list [get_ports $port] [get_pins ${portRef}_LUT1_$i/O]]
##          } elseif {$i==$levels} {
##             regexp {(.*)\[(\d*)\]} $clock clock clockName clockIndex
##             if {[info exists clockIndex]} {
##                set clockRef ${clockName}_$clockIndex
##             } else {
##                set clockRef $clock
##             }
##             create_net ${portRef}_$i
##             create_cell -reference FDRE ${portRef}_FDRE
##             connect_net -net ${portRef}_$i -objects [list [get_pins ${portRef}_LUT1_[expr $i-1]/I0] [get_pins ${portRef}_FDRE/Q]]
##             connect_net -net $clockRef -objects [get_pins ${portRef}_FDRE/C]
##             connect_net -net <const0> -objects [get_pins ${portRef}_FDRE/D]
##          } else {
##             create_net ${portRef}_$i
##             create_cell -reference LUT1 ${portRef}_LUT1_$i
##             set_property INIT 2'h2 [get_cells ${portRef}_LUT1_$i]
##             connect_net -net ${portRef}_$i -objects [list [get_pins ${portRef}_LUT1_[expr $i-1]/I0] [get_pins ${portRef}_LUT1_$i/O]]
##          }
##       }
##    }
## }
## proc create_input_port {port info} {
##    upvar LFH LFH
##    lassign $info levels loads clock direction
##    #Support for only 1 clock at this time
##    set clock [lindex $clock 0]
##    puts $LFH "Creating logic for input port: $port\tClock port: $clock\tLevels of logic: $levels"
##    regexp {(.*)\[(\d*)\]} $port port portName portIndex
##    if {[info exists portIndex]} {
##       create_port -direction $direction $portName -from $portIndex -to $portIndex
##       set portRef ${portName}_$portIndex
##    } else {
##       create_port -direction $direction $port
##       set portRef $port
##    } 
## 
##    #puts "\tCreating Nets and Cells for $port using unique reference $portRef"
##    if {[string match $clock "none"]} {
##       puts "Critical Warnings: Created input port $port with no synchronous loads. Consider removing this port from the RP interface."
##       return
##    } elseif {$levels==0} {
##       regexp {(.*)\[(\d*)\]} $clock clock clockName clockIndex
##       if {[info exists clockIndex]} {
##          set clockRef ${clockName}_$clockIndex
##       } else {
##          set clockRef $clock
##       }
##       create_net ${portRef}
##       create_cell -reference FDRE ${portRef}_FDRE
##       connect_net -net $portRef -objects [list [get_ports $port] [get_pins ${portRef}_FDRE/D]]
##       connect_net -net $clockRef -objects [get_pins ${portRef}_FDRE/C]
##    } else {
##       for {set i 0} {$i <= $levels} {incr i} {
##          if {$i==0} {
##             create_net ${portRef}_$i
##             create_cell -reference LUT1 ${portRef}_LUT1_$i
##             set_property INIT 2'h2 [get_cells ${portRef}_LUT1_$i]
##             connect_net -net ${portRef}_$i -objects [list [get_ports $port] [get_pins ${portRef}_LUT1_$i/I0]]
##          } elseif {$i==$levels} {
##             regexp {(.*)\[(\d*)\]} $clock clock clockName clockIndex
##             if {[info exists clockIndex]} {
##                set clockRef ${clockName}_$clockIndex
##             } else {
##                set clockRef $clock
##             }
##             create_net ${portRef}_$i
##             create_cell -reference FDRE ${portRef}_FDRE
##             connect_net -net ${portRef}_$i -objects [list [get_pins ${portRef}_LUT1_[expr $i-1]/O] [get_pins ${portRef}_FDRE/D]]
##             connect_net -net $clockRef -objects [get_pins ${portRef}_FDRE/C]
##          } else {
##             create_net ${portRef}_$i
##             create_cell -reference LUT1 ${portRef}_LUT1_$i
##             set_property INIT 2'h2 [get_cells ${portRef}_LUT1_$i]
##             connect_net -net ${portRef}_$i -objects [list [get_pins ${portRef}_LUT1_[expr $i-1]/O] [get_pins ${portRef}_LUT1_$i/I0]]
##          }
##       }
##    }
## }
## proc get_loads { port } {
##    set direction  [get_property DIRECTION [get_ports $port]]
##    if {[string match "IN" $direction]} {
##       #Filter out clocks
##       set clockLoads [llength [get_pins -quiet -leaf -of [get_nets -quiet -of [get_ports $port]] -filter IS_CLOCK]]
##       if {$clockLoads > 0} {
##          return [list 0 $clockLoads is_clock $direction]
##       }
##       set logicLevel [lindex [lsort [get_property -quiet LOGIC_LEVELS [get_timing_paths -quiet -from [get_ports $port] -to [all_fanout -quiet -endpoint -flat [get_ports $port]]]]] end]
##       if {[llength $logicLevel]} {
##          set loads [all_fanout -quiet -endpoint -flat -only_cells [get_ports $port]]
##          set clockPort [get_ports -of [get_nets -of [get_pins -of [get_cells $loads] -filter IS_CLOCK]]]
##          if {[llength $clockPort] > 1} {
##             puts "INFO: Found loads driven by port $port with different clock sources.\nClocks found for $port:\n\t[join $clockPort \n\t]"
##          }
##          return [list $logicLevel [llength $loads] [get_property NAME $clockPort] $direction]
##       } else {
##          return [list 0 0 none $direction]
##       }
##    } else {
##       set logicLevel [lindex [lsort [get_property -quiet LOGIC_LEVELS [get_timing_paths -quiet -from [all_fanin -quiet -startpoint -flat [get_ports $port]] -to [get_ports $port]]]] end]
##       if {[llength $logicLevel]} {
##          set driver [all_fanin -quiet -startpoint -flat -only_cells [get_ports $port]]
##          set clockPort [get_ports -of [get_nets -of [get_pins -of [get_cells $driver] -filter IS_CLOCK]]]
##          return [list $logicLevel 1 [get_property NAME $clockPort] $direction]
##       } else {
##          return [list 0 0 none $direction]
##       }
##    }
## }
## proc create_pr_budget { args } {
##    set FH "stdout"
##    set excludePins ""
## 
##    #Override defaults with command options
##    set argLength [llength $args]
##    set index 0
##    while {$index < $argLength} {
##       set arg [lindex $args $index]
##       set value [lindex $args [expr $index+1]]
##       switch -exact -- $arg {
##          {-cell}     {set cell [get_cells $value]}
##          {-file}     {set FH [open $value w]}
##          {-exclude}  {set excludePins $value}
##          {-help}     {set     helpMsg "Description:"
##                       lappend helpMsg "Creates set_max_delay constraints for initial PR run.\n"
##                       lappend helpMsg "Syntax:"
##                       lappend helpMsg "create_pr_budget\ -cell <arg> \[-file <arg>] \[-exclude\]\n"
##                       lappend helpMsg "Usage:"
##                       lappend helpMsg "  Name                        Description"
##                       lappend helpMsg "  ---------------------------------------"
##                       lappend helpMsg "  \[-cell]                     Specifies the PR cell to process."
##                       lappend helpMsg "  \[-file]                     Optional. Specifies the output file name."
##                       lappend helpMsg "                              If not specified the output will be written to STDOUT"
##                       lappend helpMsg "  \[-exclude]                  Optional. List of pins to skip."
##                       lappend helpMsg "                              Specifies local pin names without hierachy"
##                       lappend helpMsg "  \[-help]                     Displays this message\n\n"
##                       foreach line $helpMsg {
##                          puts $line
##                       }
##                       return
##                      }
##          default     {set errMsg "ERROR: Specified argument $arg is not supported.\n"
##                       append errMsg "Supported arguments are -help, -cell, and -file.\n"
##                       append errMsg "Use the -help option for more details"
##                       error $errMsg 
##                      }
##       }
##       set index [expr $index + 2]
##    }
## 
##    set_msg_config -id "Constraints 18-514" -suppress
##    set_msg_config -id "Constraints 18-515" -suppress
##    set_msg_config -id "Constraints 18-402" -suppress
##    puts $FH "####Budget constraints for cell $cell####"
## 
## 
##    set filter "REF_NAME=~FD* || REF_NAME=~RAMB* || REF_NAME=~DSP* || REF_NAME=~SRL*"
## 
##    #Process Input Pins. Ignore pins tied to clock logic, IO buffer, or VCC/GND 
##    set inputs [get_pins -of [get_cells $cell] -filter DIRECTION==IN]
##    puts "\tProcessing Input Pins of cell $cell ([llength $inputs] pins)"
##    puts $FH "#Input pins:"
##    set count 0
##    foreach pin [lsort -dict $inputs] {
##       if {[lsearch -exact $excludePins [lindex [split $pin /] end]] > "-1"} {
##          puts "\tInfo: Skipping excluded pin $pin"
##          continue
##       }
##       set HD_LUT [get_cells -quiet -of [get_pins -quiet -leaf -filter NAME=~$cell/HD_PR* -of [get_nets -quiet -of [get_pins $pin]]]]
##       if {[llength $HD_LUT]} {
##          #Get the cell names and filter out GTs, BUFG, IBUF, etc.
##          set startPointCells [get_cells -quiet -filter $filter [all_fanin -quiet -startpoints_only -flat -only_cells $pin]]
##          set clockPins [get_pins -quiet -filter IS_CLOCK -of $startPointCells]
##          set clocks [get_clocks -quiet -of $clockPins]
##          if {[llength $clocks]} {
##             foreach clock $clocks {
##                set timingPaths [get_timing_paths -quiet -from $startPointCells -through $pin -nworst 100000 -filter STARTPOINT_CLOCK==$clock]
##                if {![llength $timingPaths]} {
##                    puts "\tInfo: No timing path found through pin $pin for clock $clock." 
##                   continue
##                }
##                set startPointPins [get_pins [get_property STARTPOINT_PIN $timingPaths] -filter $filter]
##                set logicLevels [lindex [lsort -dict [get_property LOGIC_LEVELS $timingPaths]] end]
##                set period [get_property PERIOD [get_clocks $clock]]
##                #If driver is RAMB*, add level of logic to account for large clk2out times
##                if {[lsearch [get_property REF_NAME $startPointPins] "RAMB*"] > "-1"} {
##                   set logicLevels [expr $logicLevels + 2]
##                }
##                if {$logicLevels < 1} {
##                   set percentage "0.4"
##                } elseif {$logicLevels < 2} {
##                   set percentage "0.5"
##                } elseif {$logicLevels < 3} {
##                   set percentage "0.6"
##                } elseif {$logicLevels < 4} {
##                   set percentage "0.7"
##                } elseif {$logicLevels > 4} {
##                   set percentage "0.8"
##                   puts "\tCritical Warning: Path found with $logicLevels levels of logic through pin $pin. Consider revising interface."
##                   puts "\tPath has load clock $clock with period of ${period}ns. Interface budget set to ${percentage} of period."
##                }
## 
##                set value [expr $period * $percentage]
##                puts $FH "#Pin: $pin\tLogic Levels: $logicLevels\tClock: $clock\tPeriod: $period\tBudget: $percentage"
##                puts $FH "set_max_delay -datapath_only -from \[get_pins \[list $startPointPins\]\] -to \[get_pins $HD_LUT/I0\] $value"
##                incr count
##             }
##          } elseif {[llength $clockPins]} {
##             puts "Critical Warning: Found [llength $clockPins] clock pins \{$clockPins\} on source cells \{[lindex $startPointCells 0]\} of input pin $pin, but no clocks were defined. Ensure all required constraints have been defined. Try \"get_clocks -of \[get_pins [lindex $clockPins 0]\]\"" 
##          }
##       }
##       if {![string match $FH "stdout"]} {
##          flush $FH
##       }
##    }
##    puts "\tAdded $count input path segmentation constraints for $cell"
## 
## 
## 
## 
##    #Process output pins. Add set_logic_dc to prevent timing arc 
##    #from being disabled by a constant (LUT1 connected to GND).
##    set outputs [get_pins -of [get_cells $cell] -filter DIRECTION==OUT]
##    puts "\tProcessing Output Pins of cell $cell ([llength $outputs] pins)"
##    puts $FH "\n#Output pins:"
##    set count 0
##    foreach pin [lsort -dict $outputs] {
##       if {[lsearch -exact $excludePins [lindex [split $pin /] end]] > "-1"} {
##          puts "\tInfo: Skipping excluded pin $pin"
##          continue
##       }
##       set HD_LUT [get_cells -quiet -of [get_pins -quiet -leaf -filter NAME=~$cell/HD_PR* -of [get_nets -quiet -of [get_pins $pin]]]]
##       if {[llength $HD_LUT]} {
##          #Set a DC on LUT initially to prevent constant propagation, or no timing paths will be found, and all_fanout will return 0 endpoints
##          set_logic_dc  [get_pins $HD_LUT/I0]
##          #Get the cell names and filter out GTs, OBUF, etc.
##          set endPointCells [get_cells -quiet -filter $filter [all_fanout -quiet -endpoints_only -flat -only_cells $pin]]
##          set clockPins [get_pins -quiet -filter IS_CLOCK -of $endPointCells]
##          set clocks [get_clocks -quiet -of $clockPins]
##          if {[llength $clocks]} {
##             #Add set_logic_dc to XDC or set_max_delay on outputs wont't work. Only set once on pins with endpoints.
##             puts $FH "set_logic_dc \[get_pins $HD_LUT/I0\]"
##             foreach clock $clocks {
##                set timingPaths [get_timing_paths -quiet -through $pin -to $endPointCells -max_paths 100000 -filter ENDPOINT_CLOCK==$clock]
##                if {![llength $timingPaths]} {
##                    puts "\tCritical Warning: No timing path found through pin $pin for clock $clock." 
##                   continue
##                }
##                set endPointPins [get_pins [get_property ENDPOINT_PIN $timingPaths] -filter $filter]
##                set logicLevels [lindex [lsort -dict [get_property LOGIC_LEVELS $timingPaths]] end]
##                set period [get_property PERIOD [get_clocks $clock]]
##                if {$logicLevels < 1} {
##                   set percentage "0.4"
##                } elseif {$logicLevels < 2} {
##                   set percentage "0.5"
##                } elseif {$logicLevels < 3} {
##                   set percentage "0.6"
##                } elseif {$logicLevels < 4} {
##                   set percentage "0.7"
##                } elseif {$logicLevels > 4} {
##                   set percentage "0.8"
##                   puts "\tCritical Warning: Path found with $logicLevels levels of logic through pin $pin. Consider revising interface."
##                   puts "\tPath has load clock $clock with period of ${period}ns. Interface budget set to ${percentage} of period."
##                }
##                #puts "Pin: $pin\nLoad Data Pin: $end\nLoad Clock Pin: $clock\nPeriod: $period"
##                set value [expr $period * $percentage]
##                puts $FH "#Pin: $pin\tLogic Levels: $logicLevels\tClock: $clock\tPeriod: $period\tBudget: $percentage"
##                puts $FH "set_max_delay -datapath_only -from \[get_pins $HD_LUT/O\] -to \[get_pins \[list $endPointPins\]\] $value"
##                incr count
##             }
##          } elseif {[llength $clockPins]} {
##             puts "Critical Warning: Found [llength $clockPins] clock pins \{$clockPins\} on load cells \{[lindex $endPointCells 0]\} of output pin $pin, but no clocks were defined. Ensure all required constraints have been defined. Try \"get_clocks -of \[get_pins [lindex $clockPins 0]\]\"" 
##          }
##       }
##       if {![string match $FH "stdout"]} {
##          flush $FH
##       }
##    }
##    puts "\tAdded $count output path segmentation constraints for $cell"
## 
## 
## 
## 
##    if {![string match $FH "stdout"]} {
##       close $FH
##    }
##    reset_msg_config -quiet -id "Constraints 18-514" -suppress
##    reset_msg_config -quiet -id "Constraints 18-515" -suppress
##    reset_msg_config -quiet -id "Constraints 18-402" -suppress
## }
## proc analyze_pr_interface { DCPs {file "pr_timing_analysis"} {debug 0} } {
##    set_msg_config -id "Constraints 18-514" -suppress
##    set_msg_config -id "Constraints 18-515" -suppress
##    set_msg_config -id "Constraints 18-402" -suppress
## 
##    set filter "REF_NAME=~FD* || REF_NAME=~RAMB* || REF_NAME=~DSP* || REF_NAME=~SRL*"
##    set pblocks ""
##    foreach dcp $DCPs {
##       puts "Opening Checkpoint $dcp"
##       open_checkpoint $dcp > open_checkpoint.log
##       set RPs [get_rps]
##       if {[llength $RPs]} {
##          puts "Found [llength $RPs] cells marked with HD.RECONFIGURABLE"
##       }
## 
##       #Carve out RP cells if not already blackbox
##       set lock 0
##       foreach cell $RPs {
##          if {![get_property IS_BLACKBOX [get_cells $cell]]} {
##             puts "Info: Specified cell $cell in DCP $dcp is not a blackbox. Creating Blackbox."
##             update_design -cell $cell -black_box > black_box.log
##             set lock 1
##          }
##       }
## 
##       #Lock Static design if needed. If RP were already BB, assume lock_design already run.
##       if {$lock} {
##          lock_design -level routing
##       }
##       
##       #Insert LUT1 for each RP
##       foreach cell $RPs {
##          puts "Buffering ports on RP cell $cell"
##          update_design -cell $cell -buffer_ports > buffer_ports.log
##       }
## 
##       #Place/Route LUT1 buffers
##       puts "Placing RP port buffers"
##       place_design > place_design.log
##       if {$debug} {
##          write_checkpoint -force static_inserted_place.dcp
##       }
##       puts "Routing RP port buffers"
##       route_design > route_design.log
##       if {$debug} {
##          write_checkpoint -force static_inserted_route.dcp
##       }
##       
##       foreach cell $RPs {
##          set pblock [get_pblocks -of [get_cells $cell]]
##          if {[lsearch -exact $pblocks $pblock] < 0} {
##             lappend pblocks $pblock
##          }
##          #Process Input Pins. Ignore pins tied to clock logic, IO buffer, or VCC/GND 
##          set inputs [get_pins -of [get_cells $cell] -filter DIRECTION==IN]
##          puts "Processing Input Pins of cell $cell ([llength $inputs] pins)"
##          if {$debug} {
##             set count 0
##          }
##          foreach pin [lsort -dict $inputs] {
##             if {$debug} {
##                if {$count==10} {
##                   break
##                }
##                incr count
##                puts "pin$count: $pin"
##             }
##             set HD_LUT [get_cells -quiet -of [get_pins -quiet -leaf -filter NAME=~$cell/HD_PR* -of [get_nets -quiet -of [get_pins $pin]]]]
##             if {[llength $HD_LUT]} {
##                #Get the cell names and filter out GTs, BUFG, IBUF, etc.
##                set startPointCells [get_cells -quiet -filter $filter [all_fanin -quiet -startpoints_only -flat -only_cells $pin]]
##                set clockPins [get_pins -quiet -filter IS_CLOCK -of $startPointCells]
##                set clocks [get_clocks -quiet -of $clockPins]
##                if {[llength $clocks]} {
##                   foreach clock $clocks {
##                      set timingPaths [get_timing_paths -quiet -from $startPointCells -through $pin -nworst 100000 -filter STARTPOINT_CLOCK==$clock]
##                      if {![llength $timingPaths]} {
##                          puts "\tInfo: No timing path found through pin $pin for clock $clock." 
##                         continue
##                      }
##                      set startPointPins [get_pins [get_property STARTPOINT_PIN $timingPaths] -filter $filter]
##                      set period [get_property PERIOD [get_clocks $clock]]
##                      set_max_delay -datapath_only -from [get_pins [list $startPointPins]] -to [get_pins $HD_LUT/I0] $period
##                      set timing_path [get_timing_path -quiet -through [get_pins $pin]]
##                      set startClock  [get_property STARTPOINT_CLOCK $timing_path]
##                      set requirement [get_property REQUIREMENT $timing_path]
##                      set slack       [get_property SLACK $timing_path]
##                      set levels      [get_property LOGIC_LEVELS $timing_path]
##                      set totalDelay  [get_property DATAPATH_DELAY $timing_path]
##                      #Check to see if array entry already exists. If not, check that requirement matches
##                      if {$debug} {
##                         puts "DEBUG: key:${pin}.${clock} Requirement: $requirement Clock: $startClock"
##                      }
##                      if {[info exists pinDelays_${pblock}(${pin}.${clock})]} {
##                         set checkRequirement [lindex [set pinDelays_${pblock}\(${pin}.${clock}\)] 0]
##                         if {$checkRequirement != $requirement} {
##                            puts "Critical Warning: Requirement of $requirement for pin $pin of DCP $dcp is different from previous DCP with requirement of $checkRequirement"
##                         }
##                         set checkClock [lindex [set pinDelays_${pblock}\(${pin}.${clock}\)] 1]
##                         if {$checkClock != $startClock} {
##                            puts "Critical Warning: Clock $startClock for pin $pin of DCP $dcp is different from previous DCP with clock of $checkClock"
##                            set pinDelays_${pblock}(${pin}.${clock}) [lreplace [set pinDelays_${pblock}\(${pin}.${clock}\)] 1 1 $startClock]
##                         }
##                            #lappend pinDelays_${pblock}(${pin}.${clock}) [list $slack $levels $totalDelay $dcp]
##                            set pinDelays_${pblock}(${pin}.${clock}) [list [lindex [set pinDelays_${pblock}\(${pin}.${clock}\)] 0] [lindex [set pinDelays_${pblock}\(${pin}.${clock}\)] 1] [linsert [lindex [set pinDelays_${pblock}\(${pin}.${clock}\)] 2] 0 [list $slack $levels $totalDelay $dcp]]]
##                      } else {
## #puts "Setting pin $pin"
##                         set pinDelays_${pblock}(${pin}.${clock}) [list $requirement $startClock [list [list $slack $levels $totalDelay $dcp]]]
##                      }
## #                     if {[string match "null" $checkClock]} {
## #                        puts "DEBUG: Found null clock for pin $pin with clock $checkClock. Value should be $startClock."
## #                     }
##                   }
##                } elseif {[llength $clockPins]} {
##                   puts "Critical Warning: Found [llength $clockPins] clock pins driving input pin $pin, but no clocks were defined. Ensure all required constraints have been defined." 
##                }
##             }
##          }
##       
##       
##          #Process output pins. Add set_logic_dc to prevent timing arc 
##          #from being disabled by a constant (LUT1 connected to GND).
##          set outputs [get_pins -of [get_cells $cell] -filter DIRECTION==OUT]
##          puts "Processing Output Pins of cell $cell ([llength $outputs] pins)"
##          if {$debug} {
##             set count 0
##          }
##          foreach pin [lsort -dict $outputs] {
##             if {$debug} {
##                if {$count==10} {
##                   break
##                }
##                incr count
##                puts "pin$count: $pin"
##             }
##             set HD_LUT [get_cells -quiet -of [get_pins -quiet -leaf -filter NAME=~$cell/HD_PR* -of [get_nets -quiet -of [get_pins $pin]]]]
##             if {[llength $HD_LUT]} {
##                #Set a DC on LUT initially to prevent constant propagation, or no timing paths will be found, and all_fanout will return 0 endpoints
##                set_logic_dc  [get_pins $HD_LUT/I0]
##                #Get the cell names and filter out GTs, OBUF, etc.
##                set endPointCells [get_cells -quiet -filter $filter [all_fanout -quiet -endpoints_only -flat -only_cells $pin]]
##                set clockPins [get_pins -quiet -filter IS_CLOCK -of $endPointCells]
##                set clocks [get_clocks -quiet -of $clockPins]
##                if {[llength $clocks]} {
##                   #Add set_logic_dc to XDC or set_max_delay on outputs wont't work. Only set once on pins with endpoints.
##                   foreach clock $clocks {
##                      set timingPaths [get_timing_paths -quiet -through [get_pins $pin] -to $endPointCells -filter ENDPOINT_CLOCK==$clock]
##                      if {![llength $timingPaths]} {
##                          puts "\tCritical Warning: No timing path found through pin $pin for clock $clock." 
##                         continue
##                      }
##                      set endPointPins [get_pins -quiet [get_property ENDPOINT_PIN $timingPaths] -filter $filter]
##                      set period [get_property PERIOD [get_clocks $clock]]
##                      set_max_delay -datapath_only -from [get_pins $HD_LUT/O] -to [get_pins [list $endPointPins]] $period
##                      set timing_path [get_timing_path -quiet -through $pin -to $endPointCells -max_paths 100000 -filter ENDPOINT_CLOCK==$clock]
##                      set endClock    [get_property ENDPOINT_CLOCK $timing_path]
##                      set requirement [get_property REQUIREMENT $timing_path]
##                      set slack       [get_property SLACK $timing_path]
##                      set levels      [get_property LOGIC_LEVELS $timing_path]
##                      set totalDelay  [get_property DATAPATH_DELAY $timing_path]
##                      #Check to see if array entry already exists. Add if not, and check that requirement matches if so
##                      if {$debug} {
##                         puts "DEBUG: key:${pin}.${clock} Requirement: $requirement Clock: $endClock"
##                      }
##                      if {[info exists pinDelays_${pblock}(${pin}.${clock})]} {
##                         set checkRequirement [lindex [set pinDelays_${pblock}\(${pin}.${clock}\)] 0]
##                         if {$checkRequirement != $requirement} {
##                            puts "Critical Warning: Requirement of $requirement for pin $pin of DCP $dcp is different from previous DCP with requirement of $checkRequirement$"
##                         }
##                         set checkClock [lindex [set pinDelays_${pblock}\(${pin}.${clock}\)] 1]
##                         if {$checkClock != $endClock} {
##                            puts "Critical Warning: Clock $endClock for pin $pin of DCP $dcp is different from previous DCP with clock of $checkClock"
##                            set pinDelays_${pblock}(${pin}.${clock}) [lreplace [set pinDelays_${pblock}\(${pin}.${clock}\)] 1 1 $endClock]
##                         }
##                         #lappend pinDelays_${pblock}(${pin}.${clock}) [list [list $slack $levels $totalDelay $dcp]]
##                         set pinDelays_${pblock}(${pin}.${clock}) [list [lindex [set pinDelays_${pblock}\(${pin}.${clock}\)] 0] [lindex [set pinDelays_${pblock}\(${pin}.${clock}\)] 1] [linsert [lindex [set pinDelays_${pblock}\(${pin}.${clock}\)] 2] 0 [list $slack $levels $totalDelay $dcp]]]
##                      } else {
##                         set pinDelays_${pblock}(${pin}.${clock}) [list $requirement $endClock [list [list $slack $levels $totalDelay $dcp]]]
##                      }
##                   }
##                } elseif {[llength $clockPins]} {
##                   puts "Critical Warning: Found [llength $clockPins] clock pins for loads of output pin $pin, but no clocks were defined. Ensure all required constraints have been defined." 
##                }
##             }
##          }
##       }
##       puts "DEBUG: Closing project for $dcp"
##       close_project
##    }
## 
##    puts "\tPrinting Tables: Pblocks $pblocks"
##    foreach pblock $pblocks {
##       if {$debug} {
##          puts "DEBUG: Printing Table for $pblock"
##          puts [array get pinDelays_${pblock}]
##       }
##       set totalDCPs [llength $DCPs]
##       set title "-title {#HD: Interface timing analysis}"
##       set table " -row {\"Pin\" \"Clock\" \"Requirement\" \"Slack\" \"Levels\" \"Delay\" \"DCP\"}"
##       set indexCount 1
##       foreach {pin} [lsort -dict [array names pinDelays_${pblock}]] {
##          set pinName [lindex [split $pin "."] 0]
##          set data [lindex [array get pinDelays_${pblock}] $indexCount]
##          lassign $data requirment clock timing
##          foreach value $timing {
##             lassign $value slack levels totalDelay dcp
##             append table " -row {$pinName $clock $requirement $slack $levels $totalDelay $dcp}"
##          }
##          set indexCount [expr $indexCount + 2]
##       }
## 
##       set table ${title}${table}
##       if {[string match $file "STDOUT"]} {
##          print_table $table
##       } else {
##          puts "Writing results to ${file}_${pblock}.rpt"
##          print_table $table -file ${file}_${pblock}.rpt
##       }
##    }
## 
##    reset_msg_config -quiet -id "Constraints 18-514" -suppress
##    reset_msg_config -quiet -id "Constraints 18-515" -suppress
##    reset_msg_config -quiet -id "Constraints 18-402" -suppress
## }
# source $tclDir/hd_floorplan_utils.tcl
## proc create_ooc_clocks { cell hier_cell dir } {
##    set_param tcl.statsThreshold -1
##    set_msg_config -id "Vivado 12-1008" -suppress
##    set_msg_config -id "Vivado 12-626" -suppress
## 
##    set xdcFile "$dir/${cell}_ooc_timing.xdc"
##    if {[catch {file delete -force $xdcFile} errMSG] } {
##       append errMsg "\nERROR: Could not delete \"$xdcFile\". Verify file is closed."
##       error $errMsg
##    }
##    set fh [open "$xdcFile" w]
##    puts "\tWriting XDC file \"$xdcFile\"."
##    set in_pins [lsort [get_pins -of [get_cells $hier_cell] -filter DIRECTION==IN]]
##    puts $fh "#---------------------------------------"
##    puts $fh "# Create Clock Constraints - $hier_cell "
##    puts $fh "#---------------------------------------"
##    set portClocks ""
##    foreach inpin $in_pins {
##       set clocks [get_clocks -of [get_pins $inpin]]
##       if {[llength $clocks] > 0} {
##          foreach clock $clocks {
##             set pin_split [split $inpin "/" ]
##             set port [lindex $pin_split end]
##             lappend portClocks $clock.$port 
##             set period [get_property PERIOD [get_clocks $clock]]
##             set wave [get_property WAVEFORM [get_clocks $clock]] 
##             puts $fh "create_clock -period $period -name ${clock}.${port} \[get_ports \{$port\}] -waveform \{$wave\}"
##          }
##          if {[llength $clocks] ==2} {
##             puts $fh "set_clock_groups -name $port -physically_exclusive -group \[get_clocks \{[lindex $portClocks end]\}] -group \[get_clocks \{[lindex $portClocks end-1]\}]"
##          } 
##          set clk_src [get_cells -quiet -of [get_pins -quiet -leaf -of [get_nets [get_pins $inpin]] -filter DIRECTION==OUT]]
##          if {[llength $clk_src] == 1} {
##             set clk_src_val [get_property LOC [get_cells $clk_src]]
##             if {[llength $clk_src_val] == 1 && [get_property IS_LOC_FIXED [get_cells $clk_src]]} {
##                puts $fh "set_property HD.CLK_SRC $clk_src_val \[get_ports \{$port\}]"
##             } else {
##                puts $fh "#WARNING: Clock Source for pin \"$inpin\" ($clk_src) is not locked. Add a location constraint to the XDC prior to running this command."
##             }
##          }
##       }
##    }
##    set_msg_config -id "Timing 38-127" -suppress
##    set_msg_config -id "Timing 38-164" -suppress
##    set_msg_config -id "Vivado 12-975" -suppress
##    set numClocks [llength $portClocks]
##    puts "\tNumber of Clocks Found: $numClocks"
##    puts $fh "set_system_jitter 0.0"
##    puts "\tGetting Clock Uncertainty for inter-clock paths" 
##    puts "\tCalculating Clock Latency for all Clocks" 
##    foreach portClock $portClocks {
##       set clockSplit [split $portClock "." ]
##       set clock [lindex $clockSplit 0]
##       set clockPath [get_timing_paths -from [get_clocks $clock] -to [get_clocks $clock]]
##       if {[llength $clockPath] > 0} {
##          set uncertainty [get_property -quiet UNCERTAINTY $clockPath]
##          set startPinDelay [get_property -quiet STARTPOINT_CLOCK_DELAY $clockPath]
##          set startPin [get_property -quiet STARTPOINT_PIN $clockPath]
##          set endPin   [get_property -quiet ENDPOINT_PIN $clockPath]
##          if {[string match [get_property CLASS $startPin] "pin"]} {
##             set clkPin [get_pins -leaf -of [get_nets -of [get_pins $startPin]] -filter DIRECTION==OUT]
##          } elseif {[string match [get_property CLASS $endPin] "pin"]} {
##             set clkPin [get_pins -leaf -of [get_nets -of [get_pins $endPin]] -filter DIRECTION==OUT]
##             set startPin $endPin
##          } else {
##             puts "info: No clock pins found in timing path"
##             set clkPin ""
##          }
##          if {[llength $startPin] > 0 && [llength $clkPin] > 0} {
##             set arcDelay_max [get_property DELAY_MAX_RISE [get_timing_arcs -from [get_pins $clkPin] -to [get_pins $startPin]]]
##             set arcDelay_min [get_property DELAY_MIN_RISE [get_timing_arcs -from [get_pins $clkPin] -to [get_pins $startPin]]]
##             #Subtract off minimum arcDelay from max Path delay to get maxInsertion... visa versa for minInsertion
##             set maxInsertion [expr $startPinDelay - $arcDelay_min]
##             set minInsertion [expr $startPinDelay - $arcDelay_max]
##             puts $fh "set_clock_latency -source -max $maxInsertion \[get_clocks \{$portClock\}]" 
##             puts $fh "set_clock_latency -source -min $minInsertion \[get_clocks \{$portClock\}]" 
## 			   puts $fh "set_clock_uncertainty $uncertainty \[get_clocks \{$portClock\}]"
## 		   }
##       }
##    }
## 
##    #Generate Clock Uncertainty and asynchronous clock constraints
##    #Loop through clocks efficiently to avoid duplicate constraints being generated
##    puts "\tGetting Clock Uncertainty for intra-clock paths" 
##    for {set i 0} {$i < [expr $numClocks-1]} {incr i} {
##       set portClock1 [lindex $portClocks $i]
##       set clockSplit [split $portClock1 "." ]
##       set clock1 [lindex $clockSplit 0]
##       for {set j [expr $i+1]} {$j < $numClocks} {incr j} {
##          set portClock2 [lindex $portClocks $j]
##          set clock_split [split $portClock2 "." ]
##          set clock2 [lindex $clock_split 0]
##          set clkPath1 [get_timing_paths -from [get_clocks $clock1] -to [get_clocks $clock2]]
##          set clkPath2 [get_timing_paths -from [get_clocks $clock2] -to [get_clocks $clock1]]
##          if {[llength $clkPath1] > 0 || [llength $clkPath2] > 0 } {
##             if {[get_property -quiet SLACK $clkPath1] == "" && [get_property -quiet SLACK $clkPath2] == ""} {
##                puts $fh "set_clock_groups -asynchronous -group \[get_clocks \{$portClock1\}] -group \[get_clocks \{$portClock2\}]"
##             } 
##             if {[get_property -quiet SLACK $clkPath1] != ""} { 
##                puts $fh "set_clock_uncertainty -from \[get_clocks \{$portClock1\}] -to \[get_clocks \{$portClock2\}] [get_property -quiet UNCERTAINTY $clkPath1]"
##             }
##             if {[get_property -quiet SLACK $clkPath2] != ""} { 
##                puts $fh "set_clock_uncertainty -from \[get_clocks \{$portClock2\}] -to \[get_clocks \{$portClock1\}] [get_property -quiet UNCERTAINTY $clkPath2]"
##             }
##          }
##       }
##    }
##       
##    puts "\t#HD: create_ooc_clocks completed successfully\n"
##    reset_msg_config -quiet -id "Timing 38-127" -suppress
##    reset_msg_config -quiet -id "Timing 38-164" -suppress
##    reset_msg_config -quiet -id "Vivado 12-975" -suppress
##    reset_msg_config -quiet -id "Vivado 12-1008" -suppress
##    reset_msg_config -quiet -id "Vivado 12-626" -suppress
##    reset_param tcl.statsThreshold
##    close $fh
## }
## proc average_clock_delay {} {
##    #Generate Clock Latency Constraints based on average 
##    puts "\tCalculating Average Clock Latency for all Clocks" 
##    set maxPaths 10000
##    foreach portClock1 $portClocks {
##       set totalClock1Delay_max 0
##       set totalClock1Delay_min 0
##       set clockSplit [split $portClock1 "." ]
##       set clock1 [lindex $clockSplit 0]
##       set setupPathCount 0
##       set holdPathCount 0
##       foreach portClock2 $portClocks {
##          set clock_split [split $portClock2 "." ]
##          set clock2 [lindex $clock_split 0]
##          set clockPaths_setup [get_timing_paths -from [get_clocks $clock1] -to [get_clocks $clock2] -max_paths $maxPaths]
##          set clockPaths_hold  [get_timing_paths -from [get_clocks $clock1] -to [get_clocks $clock2] -max_paths $maxPaths -hold]
##          if {[llength $clockPaths_setup] > 0} {
##             foreach setup $clockPaths_setup {
##                incr setupPathCount
##                set startDelay_max [get_property -quiet STARTPOINT_CLOCK_DELAY $setup]
##                set totalClock1Delay_max [expr ($totalClock1Delay_max + $startDelay_max)]
##             }
##          }
##          if {[llength $clockPaths_hold] > 0} {
##             foreach hold $clockPaths_hold {
##                incr holdPathCount
##                set startDelay_min [get_property -quiet STARTPOINT_CLOCK_DELAY $hold]
##                set totalClock1Delay_min [expr ($totalClock1Delay_min + $startDelay_min)]
##             }
##          }
##       }
##       if {[llength $clockPaths_setup] > 0} {
##          set averageClock1Delay_max [expr {double(round(100*$totalClock1Delay_max / $setupPathCount))/100}]
##          puts "\tClock: $portClock1, \n\t\tTotal Setup Clock Delay: $totalClock1Delay_max, \n\t\tTotal Number of Paths: $setupPathCount, \n\t\tAverage Clock Delay: $averageClock1Delay_max"
##          puts $fh "set_clock_latency -source -max $averageClock1Delay_max \[get_clocks \{$portClock1\}]" 
##       }
##       if {[llength $clockPaths_hold] > 0} {
##          set averageClock1Delay_min [expr {double(round(100*$totalClock1Delay_min / $holdPathCount))/100}]
##          puts "\tClock: $portClock1, \n\t\tTotal Hold Clock Delay: $totalClock1Delay_min, \n\t\tTotal Number of Paths: $holdPathCount, \n\t\tAverage Clock Delay: $averageClock1Delay_min"
##          puts $fh "set_clock_latency -source -min $averageClock1Delay_min \[get_clocks \{$portClock1\}]" 
##       }
##    }
## }
## proc create_set_logic { name hier_cell dir {cell 1}} {
##    set_msg_config -id "Vivado 12-1023" -suppress
##    set_msg_config -id "Vivado 12-584" -suppress
## 
##    if {$cell} {
##       set xdcFile "$dir/${name}_ooc_optimize.xdc"
##    } else {
##       set xdcFile "$dir/${name}_optimize.xdc"
##    }
##    
##    if {[catch {file delete -force $xdcFile} errMsg] } {
##       append errMsg "\nERROR: Could not delete \"$xdcFile\". Verify file is closed."
##       error $errMsg
##    }
##    set fh [open "$xdcFile" w]
##    puts "\tWriting XDC file \"$xdcFile\"."
##    set in_pins [lsort [get_pins -of [get_cells $hier_cell] -filter DIRECTION==IN]]
##    set out_pins [lsort [get_pins -of [get_cells $hier_cell] -filter DIRECTION==OUT]]
##    #set inout_pins [lsort [get_pins -of [get_cells $hier_cell] -filter DIRECTION==INOUT]]
##    foreach inpin $in_pins {
##       set pin_split [concat {*}[split $inpin "/"]]
##       set port [lindex $pin_split end]
##       set net [get_nets -of [get_pins $inpin]]
##       if {[llength $net]==0} {
##          #for input pins with no driver. Should be tied to Vcc or Gnd in netlist design.
##          puts "\tWARNING: Found unconnected input pin \"$inpin\". If this script is being run on an optimzed (implemented) version of the design, pleaes close the current design and rerun on the synthesized netlist design (pre-implementation)."
##       } else {
##          set type [get_property TYPE [get_nets $net]]
##          if {[string match -nocase $type "POWER"]} {
##             #for inputs tied to Vcc
##             if {$cell} {
##                puts $fh "set_logic_one \[get_ports \{$port\}]"
##             } else {
##                puts $fh "set_logic_one \[get_pins \{$inpin\}]"
##             }
##          } elseif {[string match -nocase $type "GROUND"]} {
##             #for input tied to Ground
##             if {$cell} {
##                puts $fh "set_logic_zero \[get_ports \{$port\}]"
##             } else {
##                puts $fh "set_logic_zero \[get_pins \{$inpin\}]"
##             }
##          }
##       }
##    }
## 
##    foreach outpin $out_pins {
##       set pin_split [concat {*}[split $outpin "/"]]
##       set port [lindex $pin_split end]
##       set net [get_nets -of [get_pins $outpin]]
##       if {[llength $net]==0} {
##          #for output with no nets
##          if {$cell} {
##             puts $fh "set_logic_unconnected \[get_ports \{$port\}]"
##          } else {
##             puts $fh "set_logic_unconnected \[get_pins \{$outpin\}]"
##          }
##       } else {
##          set pin_count [get_property FLAT_PIN_COUNT [get_nets $net]]
##          set io_port   [get_ports -of [get_nets $net]]
##          set type      [get_property TYPE [get_nets $net]]
##          if {[llength $io_port] == 0 && $pin_count <= 1} {
##             #for output with dangling nets
##             if {$cell} {
##                puts $fh "set_logic_unconnected \[get_ports \{$port\}]"
##             } else {
##                puts $fh "set_logic_unconnected \[get_pins \{$outpin\}]"
##             }
##          } elseif {[string match -nocase $type "POWER"]} {
##             #for outputs tied to Vcc
##             if {$cell} {
##               # puts $fh "set_logic_one \[get_ports $port]"
##             } else {
##               # puts $fh "set_logic_one \[get_pins $outpin]"
##             }
##          } elseif {[string match -nocase $type "GROUND"]} {
##             #for output tied to Ground
##             if {$cell} {
##              #  puts $fh "set_logic_zero \[get_ports $port]"
##             } else {
##              #  puts $fh "set_logic_zero \[get_pins $outpin]"
##             }
##          }
##       }
##    }
##    reset_msg_config -quiet -id "Vivado 12-584" -suppress
##    reset_msg_config -quiet -id "Vivado 12-1023" -suppress
##    close $fh
## }
## proc write_hd_xdc {inst hierInst dir} {
##    reset_property HD.PARTPIN_RANGE [get_pins $hierInst/* -filter "HD.ASSIGNED_PPLOCS=~*INT*"]
##    set_property HD.LOC_FIXED 1 [get_pins $hierInst/*]
##    set file "${dir}/${inst}_phys.xdc"
##    if {[file exists $file]} {
##       file delete -force $file
##    }
##    puts "\tWriting XDC file \"$file\"."
##    write_xdc -force -cell $hierInst $file
## 
##    set file "${dir}/${inst}_ooc_budget.xdc"
##    if {[file exists $file]} {
##       file delete -force $file
##    }
##    puts "\tWriting XDC file \"$file\"."
##    ::debug::gen_hd_timing_constraints -percent 50 -of [get_cells $hierInst] -file $file
## }
## proc highlight_partpins { cell index } {
##    highlight_objects -color_index $index [get_pins $cell/*] 
## }
## proc hd_floorplan {cells} {
##    set relativeDir "Sources/xdc"
##    set projectDir "[get_property DIRECTORY [current_project]]"
##    set outputDir "${projectDir}/../../${relativeDir}"
## 
##    #If no design is open
##    #if { [catch {current_instance}] || [string match "netlist_1" [get_property NAME [current_design]]]==0 } {}
## #   if { [catch {current_instance}] } {
## #      puts "ERROR: No open design... Opened the Synthesized Design prior to running this command."
## #      return
## #   }
## 
##    #Make sure cells are passed into proc
##    if {![llength $cells]} {
##       puts "ERROR: No cells specified for command hd_floorplan."
##       return
##    }
##    
##    puts "Processing cells: $cells"
##    set cell_list ""
##    set cell_count 0
##    foreach cell $cells {
##       set cell_split [concat {*}[split $cell "/"]]
##       set cell_name [lindex $cell_split end]
##       incr cell_count
##       #If local cell name is the same for multiple instances, append a unique value
##       #This is to prevent output files from having the same name and overwriting
##       if {[lsearch -exact $cell_list $cell_name] >= 0} {
##          lappend cell_list $cell_name
##          set cell_name ${cell_name}_${cell_count}
##       } else {
##          lappend cell_list $cell_name
##       }
##       set_property HD.PARTITION 1 [get_cells $cell]
##       create_set_logic $cell_name $cell $outputDir
##       create_ooc_clocks $cell_name $cell $outputDir
##    }
## 
##    opt_design
##    place_design
##    
##    set color 1
##    set cell_list ""
##    set cell_count 0
##    foreach cell $cells {
##       set cell_split [concat {*}[split $cell "/"]]
##       set cell_name [lindex $cell_split end]
##       incr cell_count
##       #If local cell name is the same for multiple instances, append a unique value
##       #This is to prevent output files from having the same name and overwriting
##       if {[lsearch -exact $cell_list $cell_name] >= 0} {
##          lappend cell_list $cell_name
##          set cell_name ${cell_name}_${cell_count}
##       } else {
##          lappend cell_list $cell_name
##       }
##       write_hd_xdc $cell_name $cell $outputDir
##       highlight_partpins $cell $color
##       incr color
##    }
##    write_checkpoint -force $projectDir/TopDown_place_design.dcp
## }
# set device       "xc7a100t"
# set package      "csg324"
# set speed        "-1"
# set part         $device$package$speed
# check_part $part
INFO: Found part matching xc7a100tcsg324-1
# set_param project.singleFileAddWarning.Threshold 500
# set run.topSynth       0
# set run.rmSynth        0
# set run.prImpl         0
# set run.prVerify       1
# set run.writeBitstream 1
# set verbose      1
# set dcpLevel     1
# set synthDir  "./synth"
# set implDir   "./implement"
# set dcpDir    "./checkpoint"
# set bitDir    "./bitstreams"
# set srcDir     "./sources"
# set rtlDir     "$srcDir/hdl"
# set ipDir      "$srcDir/ip"
# set prjDir     "$srcDir/prj"
# set xdcDir     "$srcDir/xdc"
# set coreDir    "$srcDir/cores"
# set netlistDir "$srcDir/netlist"
# set scriptDir  "$srcDir/scripts"
# set top "patmos_top"
# set static "Static"
# add_module $static
# set_attribute module $static moduleName    $top
# set_attribute module $static top_level     1
# set_attribute module $static vlog          [list $rtlDir/Patmos.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/clocking/mig_7series_v4_0_clk_ibuf.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/clocking/mig_7series_v4_0_infrastructure.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/clocking/mig_7series_v4_0_iodelay_ctrl.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/clocking/mig_7series_v4_0_tempmon.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/controller/mig_7series_v4_0_arb_mux.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/controller/mig_7series_v4_0_arb_row_col.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/controller/mig_7series_v4_0_arb_select.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/controller/mig_7series_v4_0_bank_cntrl.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/controller/mig_7series_v4_0_bank_common.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/controller/mig_7series_v4_0_bank_compare.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/controller/mig_7series_v4_0_bank_mach.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/controller/mig_7series_v4_0_bank_queue.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/controller/mig_7series_v4_0_bank_state.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/controller/mig_7series_v4_0_col_mach.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/controller/mig_7series_v4_0_mc.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/controller/mig_7series_v4_0_rank_cntrl.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/controller/mig_7series_v4_0_rank_common.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/controller/mig_7series_v4_0_rank_mach.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/controller/mig_7series_v4_0_round_robin_arb.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/ecc/mig_7series_v4_0_ecc_buf.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/ecc/mig_7series_v4_0_ecc_dec_fix.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/ecc/mig_7series_v4_0_ecc_gen.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/ecc/mig_7series_v4_0_ecc_merge_enc.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/ecc/mig_7series_v4_0_fi_xor.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/ip_top/mig_7series_v4_0_mem_intfc.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/ip_top/mig_7series_v4_0_memc_ui_top_std.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_ddr_byte_group_io.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_ddr_byte_lane.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_ddr_phy_tempmon.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_ddr_calib_top.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_ddr_if_post_fifo.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_ddr_mc_phy.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_ddr_mc_phy_wrapper.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_ddr_of_pre_fifo.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_ddr_phy_4lanes.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_ddr_phy_init.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_ddr_phy_dqs_found_cal.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_ddr_phy_dqs_found_cal_hr.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_ddr_phy_oclkdelay_cal.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_ddr_phy_prbs_rdlvl.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_ddr_phy_rdlvl.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_ddr_phy_top.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_ddr_phy_wrcal.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_ddr_phy_wrlvl_off_delay.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_ddr_prbs_gen.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_ddr_phy_ck_addr_cmd_delay.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_ddr_phy_wrlvl.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_ddr_phy_ocd_lim.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_poc_top.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_ddr_phy_ocd_mux.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_ddr_phy_ocd_data.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_ddr_phy_ocd_samp.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_ddr_phy_ocd_edge.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_ddr_phy_ocd_cntlr.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_ddr_phy_ocd_po_cntlr.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_poc_pd.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_poc_tap_base.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_poc_meta.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_poc_edge_store.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/phy/mig_7series_v4_0_poc_cc.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/ui/mig_7series_v4_0_ui_cmd.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/ui/mig_7series_v4_0_ui_rd_data.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/ui/mig_7series_v4_0_ui_top.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/ui/mig_7series_v4_0_ui_wr_data.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/ddr2_ctrl_mig.v \
#                                                  $rtlDir/ddr2_ctrl/rtl/ddr2_ctrl.v \
#                                                  $rtlDir/clk_manager/clk_manager.v \
#                                                  $rtlDir/clk_manager/clk_manager_clk_wiz.v \
#                                            ]
# set_attribute module $static vhdl          [list $rtlDir/ocp.vhd work \
#                                                  $rtlDir/ocp_burst_to_ddr2_ctrl.vhd work \
#                                                  $rtlDir/nexys4ddr_io.vhd work \
#                                                  $rtlDir/icap_ctrl_config.vhd work \
#                                                  $rtlDir/icap_ctrl.vhd work \
#                                                  $rtlDir/ocp_to_bram.vhd work \
#                                                  $rtlDir/recon_spm.vhd work \
#                                                  $rtlDir/icap_ctrl_defs.vhd work \
#                                                  $rtlDir/tdp_sc_bram.vhd work \
# 						 $rtlDir/patmos_nexys4ddr-recon.vhdl work \
#                                            ]
# set_attribute module $static synthXDC      [list $xdcDir/nexys4ddr.xdc \
#                                                  $rtlDir/clk_manager/clk_manager.xdc \
#                                                  $rtlDir/ddr2_ctrl/constraints/ddr2_ctrl.xdc \
#                                                  $rtlDir/ddr2_ctrl/constraints/ddr2_ctrl_ooc.xdc \
#                                            ]
# set_attribute module $static synth         ${run.topSynth}
# set module1 "ocp_rw_reg"
# set module1_variant1 "ocp_rw_reg"
# set variant $module1_variant1
# add_module $variant
# set_attribute module $variant moduleName   $module1
# set_attribute module $variant vhdl         [list $rtlDir/ocp_rw_reg.vhd work \
#                                            ]
# set_attribute module $variant synth        ${run.rmSynth}
# set module1_variant2 "ocp_rw_reg_n"
# set variant $module1_variant2
# add_module $variant
# set_attribute module $variant moduleName   $module1
# set_attribute module $variant vhdl         [list $rtlDir/ocp_rw_reg_n.vhd work \
#                                            ]
# set_attribute module $variant synth        ${run.rmSynth}
# set module1_inst "ocp_rw_reg_inst_0"
# set state "implement"
# set config "config_${module1_variant1}_${state}" 
# add_implementation $config
# set_attribute impl $config top             $top
# set_attribute impl $config implXDC         [list $xdcDir/nexys4ddr.xdc \
#                                                  $xdcDir/pblocks.xdc \
#                                                  $rtlDir/clk_manager/clk_manager.xdc \
#                                                  $rtlDir/ddr2_ctrl/constraints/ddr2_ctrl.xdc \
#                                                  $rtlDir/ddr2_ctrl/constraints/ddr2_ctrl_ooc.xdc \
#                                            ]
# set_attribute impl $config partitions      [list [list $static           $top          $state   ] \
#                                                  [list $module1_variant1 $module1_inst implement] \
#                                            ]
# set_attribute impl $config pr.impl         1 
# set_attribute impl $config impl            ${run.prImpl} 
# set_attribute impl $config verify     	   ${run.prVerify} 
# set_attribute impl $config bitstream  	   ${run.writeBitstream}
# set_attribute impl $config bitstream_settings  [list "BITSTREAM.GENERAL.COMPRESS        TRUE" \
#                                                ]
# set_attribute impl $config bitstream_options   [list "-bin_file" \
#                                                ]
# set state "import"
# set config "config_${module1_variant2}_${state}" 
# add_implementation $config
# set_attribute impl $config top             $top
# set_attribute impl $config implXDC         [list $xdcDir/nexys4ddr.xdc \
#                                                  $xdcDir/pblocks.xdc \
#                                                  $rtlDir/clk_manager/clk_manager.xdc \
#                                                  $rtlDir/ddr2_ctrl/constraints/ddr2_ctrl.xdc \
#                                                  $rtlDir/ddr2_ctrl/constraints/ddr2_ctrl_ooc.xdc \
#                                            ]
# set_attribute impl $config impl            ${run.prImpl} 
# set_attribute impl $config partitions      [list [list $static           $top          $state   ] \
#                                                  [list $module1_variant2 $module1_inst implement] \
#                                            ]
# set_attribute impl $config pr.impl         1 
# set_attribute impl $config impl            ${run.prImpl} 
# set_attribute impl $config verify     	   ${run.prVerify} 
# set_attribute impl $config bitstream  	   ${run.writeBitstream} 
# set_attribute impl $config bitstream_settings  [list "BITSTREAM.GENERAL.COMPRESS        TRUE" \
#                                                ]
# set_attribute impl $config bitstream_options   [list "-bin_file" \
#                                                ]
# source $tclDir/run.tcl
## list_runs
#HD: No modules set to be synthesized
#HD: Defined modules not being synthesized:
	1. Static (patmos_top)
	2. ocp_rw_reg (ocp_rw_reg)
	3. ocp_rw_reg_n (ocp_rw_reg)
#HD: No Configurations set to be implemented
#HD: Defined Configurations not being implemented:
	1. config_ocp_rw_reg_implement
	2. config_ocp_rw_reg_n_import


## foreach module [get_modules synth] {
##    synthesize $module
## }
## foreach impl [get_implementations "td.impl impl" &&] {
##    #Override directives if directive file is specified
##    if {[info exists useDirectives]} {
##       puts "#HD: Overriding directives for implementation $impl"
##       set_directives impl $impl
##    }
##    implement $impl
## }
## foreach impl [get_implementations "impl ooc.impl" &&]  {
##    #Override directives if directive file is specified
##    if {[info exists useDirectives]} {
##       puts "#HD: Overriding directives for implementation $impl"
##       set_directives impl $impl
##    }
##    implement $impl
## }
## foreach config [sort_configurations [get_implementations "impl pr.impl" &&]]  {
##    #Override directives if directive file is specified
##    if {[info exists useDirectives]} {
##       puts "#HD: Overriding directives for configuration $config"
##       set_directives impl $config
##    }
##    implement $config
## }
## foreach impl [get_implementations "impl !td.impl !pr.impl !ooc.impl" &&]  {
##    #Override directives if directive file is specified
##    if {[info exists useDirectives]} {
##       puts "#HD: Overriding directives for implementation $impl"
##       set_directives impl $impl
##    }
##    implement $impl
## }
## set configurations [get_implementations "pr.impl verify" &&]
## if {[llength  $configurations] > 1} {
##    verify_configs $configurations
## }
#HD: Running pr_verify between initial config config_ocp_rw_reg_implement and subsequent configurations config_ocp_rw_reg_n_import
Command: pr_verify -full_check -initial ./implement/config_ocp_rw_reg_implement/patmos_top_route_design.dcp -additional ./implement/config_ocp_rw_reg_n_import/patmos_top_route_design.dcp
INFO: [Netlist 29-17] Analyzing 748 Unisim elements for replacement
INFO: [Netlist 29-28] Unisim Transformation completed in 0 CPU seconds
INFO: [Project 1-479] Netlist was created with Vivado 2016.4
INFO: [Device 21-403] Loading part xc7a100tcsg324-1
INFO: [Project 1-570] Preparing netlist for logic optimization
Parsing XDC File [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/.Xil/Vivado-10847-comp-nblpez/dcp_2/patmos_top_early.xdc]
Finished Parsing XDC File [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/.Xil/Vivado-10847-comp-nblpez/dcp_2/patmos_top_early.xdc]
Parsing XDC File [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/.Xil/Vivado-10847-comp-nblpez/dcp_2/patmos_top.xdc]
CRITICAL WARNING: [Constraints 18-1056] Clock 'clk_in' completely overrides clock 'sys_clk_pin'.
New: create_clock -period 10.000 [get_ports clk_in], [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/sources/hdl/clk_manager/clk_manager.xdc:56]
Previous: create_clock -period 10.000 -name sys_clk_pin -waveform {0.000 5.000} -add [get_ports clk_in], [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/sources/xdc/nexys4ddr.xdc:8]
Resolution: Review the constraint files and remove the redundant clock definition(s). If the clock constraints are not saved in a file, you can first save the constraints to an XDC file and reload the design once the constraints have been corrected.
INFO: [Timing 38-35] Done setting XDC timing constraints. [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/sources/hdl/clk_manager/clk_manager.xdc:57]
INFO: [Timing 38-2] Deriving generated clocks [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/sources/hdl/clk_manager/clk_manager.xdc:57]
get_clocks: Time (s): cpu = 00:00:09 ; elapsed = 00:00:07 . Memory (MB): peak = 1824.367 ; gain = 519.457 ; free physical = 8494 ; free virtual = 20266
Finished Parsing XDC File [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/.Xil/Vivado-10847-comp-nblpez/dcp_2/patmos_top.xdc]
Parsing XDC File [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/.Xil/Vivado-10847-comp-nblpez/dcp_2/patmos_top_late.xdc]
Finished Parsing XDC File [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/.Xil/Vivado-10847-comp-nblpez/dcp_2/patmos_top_late.xdc]
Reading XDEF placement.
Reading placer database...
Reading XDEF routing.
Read XDEF File: Time (s): cpu = 00:00:00.70 ; elapsed = 00:00:00.71 . Memory (MB): peak = 1848.039 ; gain = 19.668 ; free physical = 8482 ; free virtual = 20242
Restored from archive | CPU: 0.700000 secs | Memory: 20.425812 MB |
Finished XDEF File Restore: Time (s): cpu = 00:00:00.70 ; elapsed = 00:00:00.71 . Memory (MB): peak = 1848.039 ; gain = 19.668 ; free physical = 8482 ; free virtual = 20242
INFO: [Project 1-604] Checkpoint was created with Vivado v2016.4 (64-bit) build 1733598
INFO: [Vivado 12-3501] pr_verify ./implement/config_ocp_rw_reg_implement/patmos_top_route_design.dcp ./implement/config_ocp_rw_reg_n_import/patmos_top_route_design.dcp
INFO: [Netlist 29-17] Analyzing 748 Unisim elements for replacement
INFO: [Netlist 29-28] Unisim Transformation completed in 0 CPU seconds
INFO: [Project 1-479] Netlist was created with Vivado 2016.4
INFO: [Project 1-570] Preparing netlist for logic optimization
Parsing XDC File [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/.Xil/Vivado-10847-comp-nblpez/dcp_2/patmos_top_early.xdc]
Finished Parsing XDC File [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/.Xil/Vivado-10847-comp-nblpez/dcp_2/patmos_top_early.xdc]
Parsing XDC File [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/.Xil/Vivado-10847-comp-nblpez/dcp_2/patmos_top.xdc]
CRITICAL WARNING: [Constraints 18-1056] Clock 'clk_in' completely overrides clock 'sys_clk_pin'.
New: create_clock -period 10.000 [get_ports clk_in], [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/sources/hdl/clk_manager/clk_manager.xdc:56]
Previous: create_clock -period 10.000 -name sys_clk_pin -waveform {0.000 5.000} -add [get_ports clk_in], [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/sources/xdc/nexys4ddr.xdc:8]
Resolution: Review the constraint files and remove the redundant clock definition(s). If the clock constraints are not saved in a file, you can first save the constraints to an XDC file and reload the design once the constraints have been corrected.
INFO: [Timing 38-35] Done setting XDC timing constraints. [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/sources/hdl/clk_manager/clk_manager.xdc:57]
INFO: [Timing 38-2] Deriving generated clocks [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/sources/hdl/clk_manager/clk_manager.xdc:57]
Finished Parsing XDC File [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/.Xil/Vivado-10847-comp-nblpez/dcp_2/patmos_top.xdc]
Parsing XDC File [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/.Xil/Vivado-10847-comp-nblpez/dcp_2/patmos_top_late.xdc]
Finished Parsing XDC File [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/.Xil/Vivado-10847-comp-nblpez/dcp_2/patmos_top_late.xdc]
Reading XDEF placement.
Reading placer database...
Reading XDEF routing.
Read XDEF File: Time (s): cpu = 00:00:00.73 ; elapsed = 00:00:00.75 . Memory (MB): peak = 2153.758 ; gain = 19.668 ; free physical = 8279 ; free virtual = 20039
Restored from archive | CPU: 0.740000 secs | Memory: 20.509979 MB |
Finished XDEF File Restore: Time (s): cpu = 00:00:00.73 ; elapsed = 00:00:00.75 . Memory (MB): peak = 2153.758 ; gain = 19.668 ; free physical = 8279 ; free virtual = 20039
INFO: [Project 1-604] Checkpoint was created with Vivado v2016.4 (64-bit) build 1733598
INFO: [Constraints 18-1020] PR Verify Summary:
DCP1: ./implement/config_ocp_rw_reg_implement/patmos_top_route_design.dcp
  Number of reconfigurable modules compared = 1
  Number of partition pins compared         = 88
  Number of static tiles compared           = 204
  Number of static sites compared           = 3652
  Number of static cells compared           = 20151
  Number of static routed nodes compared    = 291296
  Number of static routed pips compared     = 272535

DCP2: ./implement/config_ocp_rw_reg_n_import/patmos_top_route_design.dcp
  Number of reconfigurable modules compared = 1
  Number of partition pins compared         = 88
  Number of static tiles compared           = 204
  Number of static sites compared           = 3652
  Number of static cells compared           = 20151
  Number of static routed nodes compared    = 291296
  Number of static routed pips compared     = 272535
INFO: [Vivado 12-3253] PR_VERIFY: check points ./implement/config_ocp_rw_reg_implement/patmos_top_route_design.dcp and ./implement/config_ocp_rw_reg_n_import/patmos_top_route_design.dcp are compatible
pr_verify: Time (s): cpu = 00:00:27 ; elapsed = 00:00:25 . Memory (MB): peak = 2240.758 ; gain = 1240.828 ; free physical = 8253 ; free virtual = 19953
	#HD: Parsing log file "pr_verify_results.log":
	CRITICAL WARNING: [Constraints 18-1056] Clock 'clk_in' completely overrides clock 'sys_clk_pin'.
	CRITICAL WARNING: [Constraints 18-1056] Clock 'clk_in' completely overrides clock 'sys_clk_pin'.


INFO: [Vivado 12-3253] PR_VERIFY: check points ./implement/config_ocp_rw_reg_implement/patmos_top_route_design.dcp and ./implement/config_ocp_rw_reg_n_import/patmos_top_route_design.dcp are compatible

| ------------------- | ------------- | ------------------------- | ----------------------------------------------------------------- |
| Phase               | Time in Phase | Time/Date                 | Description                                                       |
| ------------------- | ------------- | ------------------------- | ----------------------------------------------------------------- |
| pr_verify           | 00h:00m:25s   | 16:26:28 Fri Feb 24 2017  | 2 Configurations                                                  |
| ------------------- | ------------- | ------------------------- | ----------------------------------------------------------------- |
## set configurations [get_implementations "pr.impl bitstream" &&]
## if {[llength  $configurations] > 0} {   #### Set Tcl Params
##    if {[info exists tclParams] && [llength $tclParams] > 0} {
##       set_parameters $tclParams
##    }
##    generate_pr_bitstreams $configurations
## }
	#HD: Setting Tcl Params:
	hd.visual == 0


	#HD: Running write_bitstream on config_ocp_rw_reg_implement
Command: open_checkpoint ./implement/config_ocp_rw_reg_implement/patmos_top_route_design.dcp

Starting open_checkpoint Task

Time (s): cpu = 00:00:00 ; elapsed = 00:00:00 . Memory (MB): peak = 2240.758 ; gain = 0.000 ; free physical = 8248 ; free virtual = 19954
INFO: [Netlist 29-17] Analyzing 748 Unisim elements for replacement
INFO: [Netlist 29-28] Unisim Transformation completed in 0 CPU seconds
INFO: [Project 1-479] Netlist was created with Vivado 2016.4
INFO: [Project 1-570] Preparing netlist for logic optimization
Parsing XDC File [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/.Xil/Vivado-10847-comp-nblpez/dcp/patmos_top_early.xdc]
Finished Parsing XDC File [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/.Xil/Vivado-10847-comp-nblpez/dcp/patmos_top_early.xdc]
Parsing XDC File [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/.Xil/Vivado-10847-comp-nblpez/dcp/patmos_top.xdc]
CRITICAL WARNING: [Constraints 18-1056] Clock 'clk_in' completely overrides clock 'sys_clk_pin'.
New: create_clock -period 10.000 [get_ports clk_in], [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/sources/hdl/clk_manager/clk_manager.xdc:56]
Previous: create_clock -period 10.000 -name sys_clk_pin -waveform {0.000 5.000} -add [get_ports clk_in], [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/sources/xdc/nexys4ddr.xdc:8]
Resolution: Review the constraint files and remove the redundant clock definition(s). If the clock constraints are not saved in a file, you can first save the constraints to an XDC file and reload the design once the constraints have been corrected.
INFO: [Timing 38-35] Done setting XDC timing constraints. [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/sources/hdl/clk_manager/clk_manager.xdc:57]
INFO: [Timing 38-2] Deriving generated clocks [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/sources/hdl/clk_manager/clk_manager.xdc:57]
Finished Parsing XDC File [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/.Xil/Vivado-10847-comp-nblpez/dcp/patmos_top.xdc]
Parsing XDC File [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/.Xil/Vivado-10847-comp-nblpez/dcp/patmos_top_late.xdc]
Finished Parsing XDC File [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/.Xil/Vivado-10847-comp-nblpez/dcp/patmos_top_late.xdc]
Reading XDEF placement.
Reading placer database...
Reading XDEF routing.
Read XDEF File: Time (s): cpu = 00:00:00.70 ; elapsed = 00:00:00.69 . Memory (MB): peak = 2240.758 ; gain = 0.000 ; free physical = 8218 ; free virtual = 19952
Restored from archive | CPU: 0.700000 secs | Memory: 20.410713 MB |
Finished XDEF File Restore: Time (s): cpu = 00:00:00.70 ; elapsed = 00:00:00.70 . Memory (MB): peak = 2240.758 ; gain = 0.000 ; free physical = 8218 ; free virtual = 19952
INFO: [Project 1-111] Unisim Transformation Summary:
  A total of 177 instances were transformed.
  IOBUFDS_INTERMDISABLE => IOBUFDS_INTERMDISABLE (IBUFDS_INTERMDISABLE_INT, IBUFDS_INTERMDISABLE_INT, OBUFTDS, OBUFTDS, INV): 2 instances
  IOBUF_INTERMDISABLE => IOBUF_INTERMDISABLE (IBUF_INTERMDISABLE, OBUFT): 16 instances
  OBUFDS => OBUFDS_DUAL_BUF (OBUFDS, OBUFDS, INV): 1 instances
  RAM32M => RAM32M (RAMS32, RAMS32, RAMD32, RAMD32, RAMD32, RAMD32, RAMD32, RAMD32): 126 instances
  RAM32X1S => RAM32X1S (RAMS32): 32 instances

INFO: [Project 1-604] Checkpoint was created with Vivado v2016.4 (64-bit) build 1733598
	#HD: Parsing log file "./bitstreams/open_checkpoint_config_ocp_rw_reg_implement.log":
	CRITICAL WARNING: [Constraints 18-1056] Clock 'clk_in' completely overrides clock 'sys_clk_pin'.


	Setting property BITSTREAM.GENERAL.COMPRESS        TRUE
Command: write_bitstream -force -bin_file ./bitstreams/config_ocp_rw_reg_implement
Attempting to get a license for feature 'Implementation' and/or device 'xc7a100t'
INFO: [Common 17-349] Got license for feature 'Implementation' and/or device 'xc7a100t'
Attempting to get a license: PartialReconfiguration
Feature available: PartialReconfiguration
Running DRC as a precondition to command write_bitstream
INFO: [DRC 23-27] Running DRC with 8 threads
WARNING: [DRC 23-20] Rule violation (CHECK-3) Report rule limit reached - REQP-1839 rule limit reached: 20 violations have been found.
WARNING: [DRC 23-20] Rule violation (CHECK-3) Report rule limit reached - REQP-1840 rule limit reached: 20 violations have been found.
WARNING: [DRC 23-20] Rule violation (DPIP-1) Input pipelining - DSP patmos_inst_0/core/execute/T431 input patmos_inst_0/core/execute/T431/A[29:0] is not pipelined. Pipelining DSP48 input will improve performance.
WARNING: [DRC 23-20] Rule violation (DPIP-1) Input pipelining - DSP patmos_inst_0/core/execute/T431 input patmos_inst_0/core/execute/T431/B[17:0] is not pipelined. Pipelining DSP48 input will improve performance.
WARNING: [DRC 23-20] Rule violation (DPIP-1) Input pipelining - DSP patmos_inst_0/core/execute/mulHLReg_reg input patmos_inst_0/core/execute/mulHLReg_reg/A[29:0] is not pipelined. Pipelining DSP48 input will improve performance.
WARNING: [DRC 23-20] Rule violation (DPIP-1) Input pipelining - DSP patmos_inst_0/core/execute/mulHLReg_reg input patmos_inst_0/core/execute/mulHLReg_reg/B[17:0] is not pipelined. Pipelining DSP48 input will improve performance.
WARNING: [DRC 23-20] Rule violation (DPIP-1) Input pipelining - DSP patmos_inst_0/core/execute/mulLHReg_reg input patmos_inst_0/core/execute/mulLHReg_reg/A[29:0] is not pipelined. Pipelining DSP48 input will improve performance.
WARNING: [DRC 23-20] Rule violation (DPIP-1) Input pipelining - DSP patmos_inst_0/core/execute/mulLHReg_reg input patmos_inst_0/core/execute/mulLHReg_reg/B[17:0] is not pipelined. Pipelining DSP48 input will improve performance.
WARNING: [DRC 23-20] Rule violation (DPIP-1) Input pipelining - DSP patmos_inst_0/core/execute/mulLLReg_reg input patmos_inst_0/core/execute/mulLLReg_reg/A[29:0] is not pipelined. Pipelining DSP48 input will improve performance.
WARNING: [DRC 23-20] Rule violation (DPIP-1) Input pipelining - DSP patmos_inst_0/core/execute/mulLLReg_reg input patmos_inst_0/core/execute/mulLLReg_reg/B[17:0] is not pipelined. Pipelining DSP48 input will improve performance.
WARNING: [DRC 23-20] Rule violation (DPOP-1) PREG Output pipelining - DSP patmos_inst_0/core/execute/mulHLReg_reg output patmos_inst_0/core/execute/mulHLReg_reg/P[47:0] is not pipelined (PREG=0). Pipelining the DSP48 output will improve performance and often saves power so it is suggested whenever possible to fully pipeline this function.  If this DSP48 function was inferred, it is suggested to describe an additional register stage after this function.  If the DSP48 was instantiated in the design, it is suggested to set the PREG attribute to 1.
WARNING: [DRC 23-20] Rule violation (DPOP-1) PREG Output pipelining - DSP patmos_inst_0/core/execute/mulLHReg_reg output patmos_inst_0/core/execute/mulLHReg_reg/P[47:0] is not pipelined (PREG=0). Pipelining the DSP48 output will improve performance and often saves power so it is suggested whenever possible to fully pipeline this function.  If this DSP48 function was inferred, it is suggested to describe an additional register stage after this function.  If the DSP48 was instantiated in the design, it is suggested to set the PREG attribute to 1.
WARNING: [DRC 23-20] Rule violation (DPOP-1) PREG Output pipelining - DSP patmos_inst_0/core/execute/mulLLReg_reg output patmos_inst_0/core/execute/mulLLReg_reg/P[47:0] is not pipelined (PREG=0). Pipelining the DSP48 output will improve performance and often saves power so it is suggested whenever possible to fully pipeline this function.  If this DSP48 function was inferred, it is suggested to describe an additional register stage after this function.  If the DSP48 was instantiated in the design, it is suggested to set the PREG attribute to 1.
WARNING: [DRC 23-20] Rule violation (DPOP-2) MREG Output pipelining - DSP patmos_inst_0/core/execute/T431 multiplier stage patmos_inst_0/core/execute/T431/P[47:0] is not pipelined (MREG=0). Pipelining the multiplier function will improve performance and will save significant power so it is suggested whenever possible to fully pipeline this function.  If this multiplier was inferred, it is suggested to describe an additional register stage after this function.  If there is no registered adder/accumulator following the multiply function, two pipeline stages are suggested to allow both the MREG and PREG registers to be used.  If the DSP48 was instantiated in the design, it is suggested to set both the MREG and PREG attributes to 1 when performing multiply functions.
WARNING: [DRC 23-20] Rule violation (REQP-1709) Clock output buffering - PLLE2_ADV connectivity violation. The signal ddr2_ctrl_inst_0/u_ddr2_ctrl_mig/u_ddr2_infrastructure/pll_clk3_out on the ddr2_ctrl_inst_0/u_ddr2_ctrl_mig/u_ddr2_infrastructure/plle2_i/CLKOUT3 pin of ddr2_ctrl_inst_0/u_ddr2_ctrl_mig/u_ddr2_infrastructure/plle2_i does not drive the same kind of BUFFER load as the other CLKOUT pins. Routing from the different buffer types will not be phase aligned.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_0_0 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_0_0/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_0/exReg_memOp_hword_reg[0]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_0_1 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_0_1/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_0/exReg_memOp_hword_reg[0]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_0_2 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_0_2/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_0/exReg_memOp_hword_reg[0]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_0_3 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_0_3/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_0/exReg_memOp_hword_reg[0]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_0_4 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_0_4/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_0/we_a) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_0_5 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_0_5/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_0/we_a) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_0_6 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_0_6/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_0/we_a) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_0_7 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_0_7/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_0/we_a) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_1_0 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_1_0/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_0/exReg_memOp_hword_reg[0]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_1_1 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_1_1/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_0/exReg_memOp_hword_reg[0]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_1_2 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_1_2/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_0/exReg_memOp_hword_reg[0]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_1_3 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_1_3/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_0/exReg_memOp_hword_reg[0]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_1_4 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_1_4/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_0/we_a) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_1_5 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_1_5/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_0/we_a) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_1_6 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_1_6/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_0/we_a) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_1_7 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_1_7/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_0/we_a) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_1/ram_reg_0_0 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_1/ram_reg_0_0/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_1/exReg_memOp_byte_reg[0]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_1/ram_reg_0_1 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_1/ram_reg_0_1/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_1/exReg_memOp_byte_reg[0]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_1/ram_reg_0_2 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_1/ram_reg_0_2/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_1/exReg_memOp_byte_reg[0]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_1/ram_reg_0_3 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_1/ram_reg_0_3/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_1/exReg_memOp_byte_reg[0]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock/mem_reg/ADDRBWRADDR[10] (net: patmos_inst_0/core/dcache/sc/MemBlock/ADDRBWRADDR[6]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock/mem_reg/ADDRBWRADDR[11] (net: patmos_inst_0/core/dcache/sc/MemBlock/ADDRBWRADDR[7]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock/mem_reg/ADDRBWRADDR[12] (net: patmos_inst_0/core/dcache/sc/MemBlock/ADDRBWRADDR[8]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock/mem_reg/ADDRBWRADDR[4] (net: patmos_inst_0/core/dcache/sc/MemBlock/ADDRBWRADDR[0]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock/mem_reg/ADDRBWRADDR[5] (net: patmos_inst_0/core/dcache/sc/MemBlock/ADDRBWRADDR[1]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock/mem_reg/ADDRBWRADDR[6] (net: patmos_inst_0/core/dcache/sc/MemBlock/ADDRBWRADDR[2]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock/mem_reg/ADDRBWRADDR[7] (net: patmos_inst_0/core/dcache/sc/MemBlock/ADDRBWRADDR[3]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock/mem_reg/ADDRBWRADDR[8] (net: patmos_inst_0/core/dcache/sc/MemBlock/ADDRBWRADDR[4]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock/mem_reg/ADDRBWRADDR[9] (net: patmos_inst_0/core/dcache/sc/MemBlock/ADDRBWRADDR[5]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock/mem_reg/ENARDEN (net: patmos_inst_0/core/dcache/sc/MemBlock/mem_reg_i_1__1_n_0) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg/ADDRBWRADDR[10] (net: patmos_inst_0/core/dcache/sc/MemBlock_1/ADDRBWRADDR[6]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg/ADDRBWRADDR[11] (net: patmos_inst_0/core/dcache/sc/MemBlock_1/ADDRBWRADDR[7]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg/ADDRBWRADDR[12] (net: patmos_inst_0/core/dcache/sc/MemBlock_1/ADDRBWRADDR[8]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg/ADDRBWRADDR[4] (net: patmos_inst_0/core/dcache/sc/MemBlock_1/ADDRBWRADDR[0]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg/ADDRBWRADDR[5] (net: patmos_inst_0/core/dcache/sc/MemBlock_1/ADDRBWRADDR[1]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg/ADDRBWRADDR[6] (net: patmos_inst_0/core/dcache/sc/MemBlock_1/ADDRBWRADDR[2]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg/ADDRBWRADDR[7] (net: patmos_inst_0/core/dcache/sc/MemBlock_1/ADDRBWRADDR[3]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg/ADDRBWRADDR[8] (net: patmos_inst_0/core/dcache/sc/MemBlock_1/ADDRBWRADDR[4]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg/ADDRBWRADDR[9] (net: patmos_inst_0/core/dcache/sc/MemBlock_1/ADDRBWRADDR[5]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg/ENARDEN (net: patmos_inst_0/core/dcache/sc/MemBlock_1/T131) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
INFO: [Vivado 12-3199] DRC finished with 0 Errors, 55 Warnings
INFO: [Vivado 12-3200] Please refer to the DRC report (report_drc) for more information.
Partition "pblock_ocp_rw_reg" Reconfigurable Module "ocp_rw_reg_inst_0"
Loading data files...
Loading site data...
Loading route data...
Processing options...
Creating bitmap...
Creating bitstream...
Bitstream compression saved 15207968 bits.
Writing bitstream ./bitstreams/config_ocp_rw_reg_implement.bit...
Writing bitstream ./bitstreams/config_ocp_rw_reg_implement.bin...
Process Partition "pblock_ocp_rw_reg"
Loading data files...
Loading site data...
Loading route data...
Processing options...
Partition "pblock_ocp_rw_reg" has RESET_AFTER_RECONFIG = TRUE.
Creating bitmap...
Creating bitstream...
Partial bitstream contains 405504 bits.
Writing bitstream ./bitstreams/config_ocp_rw_reg_implement_pblock_ocp_rw_reg_partial.bit...
Writing bitstream ./bitstreams/config_ocp_rw_reg_implement_pblock_ocp_rw_reg_partial.bin...
INFO: [Vivado 12-1842] Bitgen Completed Successfully.
INFO: [Project 1-118] WebTalk data collection is enabled (User setting is ON. Install Setting is ON.).
INFO: [Common 17-186] '/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/usage_statistics_webtalk.xml' has been successfully sent to Xilinx on Fri Feb 24 16:27:35 2017. For additional details about this file, please refer to the WebTalk help file at /home/lpez/Xilinx/Vivado/2016.4/doc/webtalk_introduction.html.
INFO: [Common 17-83] Releasing license: Implementation
16 Infos, 55 Warnings, 1 Critical Warnings and 0 Errors encountered.
write_bitstream completed successfully
write_bitstream: Time (s): cpu = 00:00:43 ; elapsed = 00:00:38 . Memory (MB): peak = 2323.688 ; gain = 82.930 ; free physical = 8037 ; free virtual = 19751
	#HD: Parsing log file "./bitstreams/config_ocp_rw_reg_implement.log":



| ------------------- | ------------- | ------------------------- | ----------------------------------------------------------------- |
| Phase               | Time in Phase | Time/Date                 | Description                                                       |
| ------------------- | ------------- | ------------------------- | ----------------------------------------------------------------- |
| write_bitstream     | 00h:00m:42s   | 16:26:53 Fri Feb 24 2017  | config_ocp_rw_reg_implement                                       |
| ------------------- | ------------- | ------------------------- | ----------------------------------------------------------------- |
	INFO: Skipping partial BIN file generation for Configuration config_ocp_rw_reg_implement.
	#HD: Parsing log file "./bitstreams/temp.log":


	#HD: Running write_bitstream on config_ocp_rw_reg_n_import
Command: open_checkpoint ./implement/config_ocp_rw_reg_n_import/patmos_top_route_design.dcp

Starting open_checkpoint Task

Time (s): cpu = 00:00:00 ; elapsed = 00:00:00 . Memory (MB): peak = 2323.688 ; gain = 0.000 ; free physical = 8034 ; free virtual = 19752
INFO: [Netlist 29-17] Analyzing 748 Unisim elements for replacement
INFO: [Netlist 29-28] Unisim Transformation completed in 0 CPU seconds
INFO: [Project 1-479] Netlist was created with Vivado 2016.4
INFO: [Project 1-570] Preparing netlist for logic optimization
Parsing XDC File [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/.Xil/Vivado-10847-comp-nblpez/dcp/patmos_top_early.xdc]
Finished Parsing XDC File [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/.Xil/Vivado-10847-comp-nblpez/dcp/patmos_top_early.xdc]
Parsing XDC File [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/.Xil/Vivado-10847-comp-nblpez/dcp/patmos_top.xdc]
CRITICAL WARNING: [Constraints 18-1056] Clock 'clk_in' completely overrides clock 'sys_clk_pin'.
New: create_clock -period 10.000 [get_ports clk_in], [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/sources/hdl/clk_manager/clk_manager.xdc:56]
Previous: create_clock -period 10.000 -name sys_clk_pin -waveform {0.000 5.000} -add [get_ports clk_in], [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/sources/xdc/nexys4ddr.xdc:8]
Resolution: Review the constraint files and remove the redundant clock definition(s). If the clock constraints are not saved in a file, you can first save the constraints to an XDC file and reload the design once the constraints have been corrected.
INFO: [Timing 38-35] Done setting XDC timing constraints. [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/sources/hdl/clk_manager/clk_manager.xdc:57]
INFO: [Timing 38-2] Deriving generated clocks [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/sources/hdl/clk_manager/clk_manager.xdc:57]
Finished Parsing XDC File [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/.Xil/Vivado-10847-comp-nblpez/dcp/patmos_top.xdc]
Parsing XDC File [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/.Xil/Vivado-10847-comp-nblpez/dcp/patmos_top_late.xdc]
Finished Parsing XDC File [/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/.Xil/Vivado-10847-comp-nblpez/dcp/patmos_top_late.xdc]
Reading XDEF placement.
Reading placer database...
Reading XDEF routing.
Read XDEF File: Time (s): cpu = 00:00:00.70 ; elapsed = 00:00:00.71 . Memory (MB): peak = 2323.688 ; gain = 0.000 ; free physical = 8004 ; free virtual = 19751
Restored from archive | CPU: 0.700000 secs | Memory: 20.475716 MB |
Finished XDEF File Restore: Time (s): cpu = 00:00:00.70 ; elapsed = 00:00:00.71 . Memory (MB): peak = 2323.688 ; gain = 0.000 ; free physical = 8004 ; free virtual = 19751
INFO: [Project 1-111] Unisim Transformation Summary:
  A total of 177 instances were transformed.
  IOBUFDS_INTERMDISABLE => IOBUFDS_INTERMDISABLE (IBUFDS_INTERMDISABLE_INT, IBUFDS_INTERMDISABLE_INT, OBUFTDS, OBUFTDS, INV): 2 instances
  IOBUF_INTERMDISABLE => IOBUF_INTERMDISABLE (IBUF_INTERMDISABLE, OBUFT): 16 instances
  OBUFDS => OBUFDS_DUAL_BUF (OBUFDS, OBUFDS, INV): 1 instances
  RAM32M => RAM32M (RAMS32, RAMS32, RAMD32, RAMD32, RAMD32, RAMD32, RAMD32, RAMD32): 126 instances
  RAM32X1S => RAM32X1S (RAMS32): 32 instances

INFO: [Project 1-604] Checkpoint was created with Vivado v2016.4 (64-bit) build 1733598
	#HD: Parsing log file "./bitstreams/open_checkpoint_config_ocp_rw_reg_n_import.log":
	CRITICAL WARNING: [Constraints 18-1056] Clock 'clk_in' completely overrides clock 'sys_clk_pin'.


	Setting property BITSTREAM.GENERAL.COMPRESS        TRUE
Command: write_bitstream -force -bin_file ./bitstreams/config_ocp_rw_reg_n_import
Attempting to get a license for feature 'Implementation' and/or device 'xc7a100t'
INFO: [Common 17-349] Got license for feature 'Implementation' and/or device 'xc7a100t'
Running DRC as a precondition to command write_bitstream
INFO: [DRC 23-27] Running DRC with 8 threads
WARNING: [DRC 23-20] Rule violation (CHECK-3) Report rule limit reached - REQP-1839 rule limit reached: 20 violations have been found.
WARNING: [DRC 23-20] Rule violation (CHECK-3) Report rule limit reached - REQP-1840 rule limit reached: 20 violations have been found.
WARNING: [DRC 23-20] Rule violation (DPIP-1) Input pipelining - DSP patmos_inst_0/core/execute/T431 input patmos_inst_0/core/execute/T431/A[29:0] is not pipelined. Pipelining DSP48 input will improve performance.
WARNING: [DRC 23-20] Rule violation (DPIP-1) Input pipelining - DSP patmos_inst_0/core/execute/T431 input patmos_inst_0/core/execute/T431/B[17:0] is not pipelined. Pipelining DSP48 input will improve performance.
WARNING: [DRC 23-20] Rule violation (DPIP-1) Input pipelining - DSP patmos_inst_0/core/execute/mulHLReg_reg input patmos_inst_0/core/execute/mulHLReg_reg/A[29:0] is not pipelined. Pipelining DSP48 input will improve performance.
WARNING: [DRC 23-20] Rule violation (DPIP-1) Input pipelining - DSP patmos_inst_0/core/execute/mulHLReg_reg input patmos_inst_0/core/execute/mulHLReg_reg/B[17:0] is not pipelined. Pipelining DSP48 input will improve performance.
WARNING: [DRC 23-20] Rule violation (DPIP-1) Input pipelining - DSP patmos_inst_0/core/execute/mulLHReg_reg input patmos_inst_0/core/execute/mulLHReg_reg/A[29:0] is not pipelined. Pipelining DSP48 input will improve performance.
WARNING: [DRC 23-20] Rule violation (DPIP-1) Input pipelining - DSP patmos_inst_0/core/execute/mulLHReg_reg input patmos_inst_0/core/execute/mulLHReg_reg/B[17:0] is not pipelined. Pipelining DSP48 input will improve performance.
WARNING: [DRC 23-20] Rule violation (DPIP-1) Input pipelining - DSP patmos_inst_0/core/execute/mulLLReg_reg input patmos_inst_0/core/execute/mulLLReg_reg/A[29:0] is not pipelined. Pipelining DSP48 input will improve performance.
WARNING: [DRC 23-20] Rule violation (DPIP-1) Input pipelining - DSP patmos_inst_0/core/execute/mulLLReg_reg input patmos_inst_0/core/execute/mulLLReg_reg/B[17:0] is not pipelined. Pipelining DSP48 input will improve performance.
WARNING: [DRC 23-20] Rule violation (DPOP-1) PREG Output pipelining - DSP patmos_inst_0/core/execute/mulHLReg_reg output patmos_inst_0/core/execute/mulHLReg_reg/P[47:0] is not pipelined (PREG=0). Pipelining the DSP48 output will improve performance and often saves power so it is suggested whenever possible to fully pipeline this function.  If this DSP48 function was inferred, it is suggested to describe an additional register stage after this function.  If the DSP48 was instantiated in the design, it is suggested to set the PREG attribute to 1.
WARNING: [DRC 23-20] Rule violation (DPOP-1) PREG Output pipelining - DSP patmos_inst_0/core/execute/mulLHReg_reg output patmos_inst_0/core/execute/mulLHReg_reg/P[47:0] is not pipelined (PREG=0). Pipelining the DSP48 output will improve performance and often saves power so it is suggested whenever possible to fully pipeline this function.  If this DSP48 function was inferred, it is suggested to describe an additional register stage after this function.  If the DSP48 was instantiated in the design, it is suggested to set the PREG attribute to 1.
WARNING: [DRC 23-20] Rule violation (DPOP-1) PREG Output pipelining - DSP patmos_inst_0/core/execute/mulLLReg_reg output patmos_inst_0/core/execute/mulLLReg_reg/P[47:0] is not pipelined (PREG=0). Pipelining the DSP48 output will improve performance and often saves power so it is suggested whenever possible to fully pipeline this function.  If this DSP48 function was inferred, it is suggested to describe an additional register stage after this function.  If the DSP48 was instantiated in the design, it is suggested to set the PREG attribute to 1.
WARNING: [DRC 23-20] Rule violation (DPOP-2) MREG Output pipelining - DSP patmos_inst_0/core/execute/T431 multiplier stage patmos_inst_0/core/execute/T431/P[47:0] is not pipelined (MREG=0). Pipelining the multiplier function will improve performance and will save significant power so it is suggested whenever possible to fully pipeline this function.  If this multiplier was inferred, it is suggested to describe an additional register stage after this function.  If there is no registered adder/accumulator following the multiply function, two pipeline stages are suggested to allow both the MREG and PREG registers to be used.  If the DSP48 was instantiated in the design, it is suggested to set both the MREG and PREG attributes to 1 when performing multiply functions.
WARNING: [DRC 23-20] Rule violation (REQP-1709) Clock output buffering - PLLE2_ADV connectivity violation. The signal ddr2_ctrl_inst_0/u_ddr2_ctrl_mig/u_ddr2_infrastructure/pll_clk3_out on the ddr2_ctrl_inst_0/u_ddr2_ctrl_mig/u_ddr2_infrastructure/plle2_i/CLKOUT3 pin of ddr2_ctrl_inst_0/u_ddr2_ctrl_mig/u_ddr2_infrastructure/plle2_i does not drive the same kind of BUFFER load as the other CLKOUT pins. Routing from the different buffer types will not be phase aligned.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_0_0 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_0_0/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_0/exReg_memOp_hword_reg[0]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_0_1 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_0_1/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_0/exReg_memOp_hword_reg[0]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_0_2 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_0_2/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_0/exReg_memOp_hword_reg[0]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_0_3 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_0_3/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_0/exReg_memOp_hword_reg[0]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_0_4 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_0_4/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_0/we_a) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_0_5 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_0_5/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_0/we_a) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_0_6 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_0_6/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_0/we_a) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_0_7 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_0_7/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_0/we_a) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_1_0 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_1_0/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_0/exReg_memOp_hword_reg[0]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_1_1 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_1_1/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_0/exReg_memOp_hword_reg[0]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_1_2 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_1_2/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_0/exReg_memOp_hword_reg[0]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_1_3 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_1_3/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_0/exReg_memOp_hword_reg[0]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_1_4 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_1_4/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_0/we_a) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_1_5 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_1_5/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_0/we_a) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_1_6 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_1_6/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_0/we_a) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_1_7 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_0/ram_reg_1_7/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_0/we_a) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_1/ram_reg_0_0 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_1/ram_reg_0_0/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_1/exReg_memOp_byte_reg[0]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_1/ram_reg_0_1 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_1/ram_reg_0_1/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_1/exReg_memOp_byte_reg[0]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_1/ram_reg_0_2 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_1/ram_reg_0_2/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_1/exReg_memOp_byte_reg[0]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1839) RAMB36 async control check - The RAMB36E1 recon_buffer_comp/tdp_sc_bram_comp_1/ram_reg_0_3 has an input control pin recon_buffer_comp/tdp_sc_bram_comp_1/ram_reg_0_3/WEA[0] (net: recon_buffer_comp/tdp_sc_bram_comp_1/exReg_memOp_byte_reg[0]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock/mem_reg/ADDRBWRADDR[10] (net: patmos_inst_0/core/dcache/sc/MemBlock/ADDRBWRADDR[6]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock/mem_reg/ADDRBWRADDR[11] (net: patmos_inst_0/core/dcache/sc/MemBlock/ADDRBWRADDR[7]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock/mem_reg/ADDRBWRADDR[12] (net: patmos_inst_0/core/dcache/sc/MemBlock/ADDRBWRADDR[8]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock/mem_reg/ADDRBWRADDR[4] (net: patmos_inst_0/core/dcache/sc/MemBlock/ADDRBWRADDR[0]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock/mem_reg/ADDRBWRADDR[5] (net: patmos_inst_0/core/dcache/sc/MemBlock/ADDRBWRADDR[1]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock/mem_reg/ADDRBWRADDR[6] (net: patmos_inst_0/core/dcache/sc/MemBlock/ADDRBWRADDR[2]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock/mem_reg/ADDRBWRADDR[7] (net: patmos_inst_0/core/dcache/sc/MemBlock/ADDRBWRADDR[3]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock/mem_reg/ADDRBWRADDR[8] (net: patmos_inst_0/core/dcache/sc/MemBlock/ADDRBWRADDR[4]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock/mem_reg/ADDRBWRADDR[9] (net: patmos_inst_0/core/dcache/sc/MemBlock/ADDRBWRADDR[5]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock/mem_reg/ENARDEN (net: patmos_inst_0/core/dcache/sc/MemBlock/mem_reg_i_1__1_n_0) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg/ADDRBWRADDR[10] (net: patmos_inst_0/core/dcache/sc/MemBlock_1/ADDRBWRADDR[6]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg/ADDRBWRADDR[11] (net: patmos_inst_0/core/dcache/sc/MemBlock_1/ADDRBWRADDR[7]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg/ADDRBWRADDR[12] (net: patmos_inst_0/core/dcache/sc/MemBlock_1/ADDRBWRADDR[8]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg/ADDRBWRADDR[4] (net: patmos_inst_0/core/dcache/sc/MemBlock_1/ADDRBWRADDR[0]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg/ADDRBWRADDR[5] (net: patmos_inst_0/core/dcache/sc/MemBlock_1/ADDRBWRADDR[1]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg/ADDRBWRADDR[6] (net: patmos_inst_0/core/dcache/sc/MemBlock_1/ADDRBWRADDR[2]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg/ADDRBWRADDR[7] (net: patmos_inst_0/core/dcache/sc/MemBlock_1/ADDRBWRADDR[3]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg/ADDRBWRADDR[8] (net: patmos_inst_0/core/dcache/sc/MemBlock_1/ADDRBWRADDR[4]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg/ADDRBWRADDR[9] (net: patmos_inst_0/core/dcache/sc/MemBlock_1/ADDRBWRADDR[5]) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
WARNING: [DRC 23-20] Rule violation (REQP-1840) RAMB18 async control check - The RAMB18E1 patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg has an input control pin patmos_inst_0/core/dcache/sc/MemBlock_1/mem_reg/ENARDEN (net: patmos_inst_0/core/dcache/sc/MemBlock_1/T131) which is driven by a register (recon_buffer_comp/ocp_to_bram_comp_0/SResp_reg[0]) that has an active asychronous set or reset. This may cause corruption of the memory contents and/or read values when the set/reset is asserted and is not analyzed by the default static timing analysis. It is suggested to eliminate the use of a set/reset to registers driving this RAMB pin or else use a synchronous reset in which the assertion of the reset is timed by default.
INFO: [Vivado 12-3199] DRC finished with 0 Errors, 55 Warnings
INFO: [Vivado 12-3200] Please refer to the DRC report (report_drc) for more information.
Partition "pblock_ocp_rw_reg" Reconfigurable Module "ocp_rw_reg_inst_0"
Loading data files...
Loading site data...
Loading route data...
Processing options...
Creating bitmap...
Creating bitstream...
Bitstream compression saved 15203424 bits.
Writing bitstream ./bitstreams/config_ocp_rw_reg_n_import.bit...
Writing bitstream ./bitstreams/config_ocp_rw_reg_n_import.bin...
Process Partition "pblock_ocp_rw_reg"
Loading data files...
Loading site data...
Loading route data...
Processing options...
Partition "pblock_ocp_rw_reg" has RESET_AFTER_RECONFIG = TRUE.
Creating bitmap...
Creating bitstream...
Partial bitstream contains 414144 bits.
Writing bitstream ./bitstreams/config_ocp_rw_reg_n_import_pblock_ocp_rw_reg_partial.bit...
Writing bitstream ./bitstreams/config_ocp_rw_reg_n_import_pblock_ocp_rw_reg_partial.bin...
INFO: [Vivado 12-1842] Bitgen Completed Successfully.
INFO: [Project 1-118] WebTalk data collection is enabled (User setting is ON. Install Setting is ON.).
INFO: [Common 17-186] '/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/usage_statistics_webtalk.xml' has been successfully sent to Xilinx on Fri Feb 24 16:28:18 2017. For additional details about this file, please refer to the WebTalk help file at /home/lpez/Xilinx/Vivado/2016.4/doc/webtalk_introduction.html.
INFO: [Common 17-83] Releasing license: Implementation
32 Infos, 110 Warnings, 2 Critical Warnings and 0 Errors encountered.
write_bitstream completed successfully
write_bitstream: Time (s): cpu = 00:00:43 ; elapsed = 00:00:38 . Memory (MB): peak = 2355.703 ; gain = 32.016 ; free physical = 8041 ; free virtual = 19727
	#HD: Parsing log file "./bitstreams/config_ocp_rw_reg_n_import.log":



| ------------------- | ------------- | ------------------------- | ----------------------------------------------------------------- |
| Phase               | Time in Phase | Time/Date                 | Description                                                       |
| ------------------- | ------------- | ------------------------- | ----------------------------------------------------------------- |
| write_bitstream     | 00h:00m:43s   | 16:27:35 Fri Feb 24 2017  | config_ocp_rw_reg_n_import                                        |
| ------------------- | ------------- | ------------------------- | ----------------------------------------------------------------- |
	INFO: Skipping partial BIN file generation for Configuration config_ocp_rw_reg_n_import.
	#HD: Parsing log file "./bitstreams/temp.log":


## close $RFH
## close $CFH
## close $WFH
start_gui
open_hw
connect_hw_server
INFO: [Labtools 27-2285] Connecting to hw_server url TCP:localhost:3121
INFO: [Labtools 27-2222] Launching hw_server...
INFO: [Labtools 27-2221] Launch Output:

****** Xilinx hw_server v2016.4
  **** Build date : Dec 14 2016-22:55:00
    ** Copyright 1986-2016 Xilinx, Inc. All Rights Reserved.


open_hw_target
INFO: [Labtoolstcl 44-466] Opening hw_target localhost:3121/xilinx_tcf/Digilent/210292A3FFC9A
current_hw_device [lindex [get_hw_devices xc7a100t_0] 0]
refresh_hw_device -update_hw_probes false [lindex [get_hw_devices xc7a100t_0] 0]
INFO: [Labtools 27-1434] Device xc7a100t (JTAG device index = 0) is programmed with a design that has no supported debug core(s) in it.
WARNING: [Labtools 27-3123] The debug hub core was not detected at User Scan Chain 1 or 3.
Resolution: 
1. Make sure the clock connected to the debug hub (dbg_hub) core is a free running clock and is active OR
2. Manually launch hw_server with -e "set xsdb-user-bscan <C_USER_SCAN_CHAIN scan_chain_number>" to detect the debug hub at User Scan Chain of 2 or 4. To determine the user scan chain setting, open the implemented design and use: get_property C_USER_SCAN_CHAIN [get_debug_cores dbg_hub].
set_property PROBES.FILE {} [lindex [get_hw_devices xc7a100t_0] 0]
set_property PROGRAM.FILE {/home/lpez/t-crest/reconfig/build/nexys4ddr-recon/bitstreams/config_ocp_rw_reg_implement.bit} [lindex [get_hw_devices xc7a100t_0] 0]
program_hw_devices [lindex [get_hw_devices xc7a100t_0] 0]
INFO: [Labtools 27-3164] End of startup status: HIGH
refresh_hw_device [lindex [get_hw_devices xc7a100t_0] 0]
INFO: [Labtools 27-1434] Device xc7a100t (JTAG device index = 0) is programmed with a design that has no supported debug core(s) in it.
WARNING: [Labtools 27-3123] The debug hub core was not detected at User Scan Chain 1 or 3.
Resolution: 
1. Make sure the clock connected to the debug hub (dbg_hub) core is a free running clock and is active OR
2. Manually launch hw_server with -e "set xsdb-user-bscan <C_USER_SCAN_CHAIN scan_chain_number>" to detect the debug hub at User Scan Chain of 2 or 4. To determine the user scan chain setting, open the implemented design and use: get_property C_USER_SCAN_CHAIN [get_debug_cores dbg_hub].
WARNING: [Labtoolstcl 44-130] No matching hw_ilas were found.
WARNING: [Labtoolstcl 44-130] No matching hw_ilas were found.
WARNING: [Labtoolstcl 44-130] No matching hw_ilas were found.
WARNING: [Labtoolstcl 44-130] No matching hw_ilas were found.
exit
INFO: [Common 17-206] Exiting Vivado at Fri Feb 24 16:56:29 2017...
